# 函数

## 函数声明

```go
func name(parameter-list) (result-list) {
    body
}
```

1. 如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。

   ```go
   func f(i, j, k int, s, t string)                 { /* ... */ }
   func f(i int, j int, k int,  s string, t string) { /* ... */ }
   ```

2. 函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。

3. 在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。

4. 实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。

## 多返回值

1. 准确的变量名可以传达函数返回值的含义。

   ```go
   func Size(rect image.Rectangle) (width, height int)
   func Split(path string) (dir, file string)
   func HourMinSec(t time.Time) (hour, minute, second int)
   ```

2. 按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。

3. 如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。

4. 当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。不宜过度使用bare return。

## 错误

1. 将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。
   1. 如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。
   2. 通常，导致失败的原因不止一种，因此，额外的返回值不再是简单的布尔类型，而是error类型。

### 错误处理策略

常用的五种方式。

1. 传播错误。fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。

   ```go
   resp, err := http.Get(url)
   if err != nil{
       return nil, err
   }
   ```

2. 如果错误的发生是偶然性的，或由不可预知的问题导致的。重新尝试失败的操作。

   ```go
   func WaitForServer(url string) error {
       const timeout = 1 * time.Minute
       deadline := time.Now().Add(timeout)
       for tries := 0; time.Now().Before(deadline); tries++ {
           _, err := http.Head(url)
           if err == nil {
               return nil // success
           }
           log.Printf("server not responding (%s);retrying…", err)
           time.Sleep(time.Second << uint(tries)) // exponential back-off
       }
       return fmt.Errorf("server %s failed to respond after %s", url, timeout)
   }
   ```

3. 如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。

   ```go
   if err := WaitForServer(url); err != nil {
       log.Fatalf("Site is down: %v\n", err)
       os.Exit(1)
   }
   ```

4. 有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数。

   ```go
   if err := Ping(); err != nil {
       log.Printf("ping failed: %v; networking disabled",err)
   }
   ```

5. 可以直接忽略掉错误。当你决定忽略某个错误时，你应该清晰地写下你的意图。

### 文件结尾错误

io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在io包中定义。

```go
package io

import "errors"

// EOF is the error returned by Read when no more input is available.
var EOF = errors.New("EOF")
```

## 函数值

1. 函数被看作第一类值【first-class values】：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。

2. 函数类型的零值是nil。调用值为nil的函数值会引起panic错误，函数值可以与nil比较：

   ```go
   var f func(int) int
   f(3) // 此处f的值为nil, 会引起panic错误
   ```

3. 函数值之间是不可比较的，也不能用函数值作为map的key。

4. 函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。

## 匿名函数

1. 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量【function literal】。
2. 函数值字面量是一种表达式，它的值被称为匿名函数【anonymous function】，区别在于func关键字后没有函数名。
3. 匿名函数可以访问完整的词法环境，在函数中定义的内部函数可以引用该函数的变量。
4. Go使用闭包【closures】技术实现函数值，Go程序员也把函数值叫做闭包。

### 警告：捕获迭代变量

循环变量的作用域：在循环中生成的所有函数值都共享相同的循环变量。函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。

通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。

## 可变参数

1. 声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“...”，这表示该函数会接收任意数量的该类型参数。
2. 函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收Printf风格的格式化字符串。

## Deferred函数

1. 只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。

2. 直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行。【defer 必须要能执行到】

3. 不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。

4. 你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。

5. defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。

6. 对匿名函数采用defer机制，可以使其观察函数的返回值。延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值。

   ```go
   func double(x int) (result int) {
       defer func() { fmt.Printf("double(%d) = %d\n", x,result) }()
       return x + x
   }
   _ = double(4)
   // Output:
   // "double(4) = 8"
   ```

7. 解决循环defer的方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。

## Panic异常

1. Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。
2. 当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数。
3. panic一般用于严重错误，如程序内部的逻辑不一致。所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。
4. runtime包允许程序员输出堆栈信息。
5. 在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。

## Recover捕获异常

1. 在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。
2. 我们也可以通过调用runtime.Stack往错误信息中添加完整的堆栈调用信息。
3. 为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为error处理，如果不是，则按照正常的panic进行处理。

# 方法

## 方法声明

1. 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
2. `p.Distance的`表达式叫做选择器。
3. 在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型。
4. 对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名。
5. 好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字。

## 指针接收器

1. 当接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法。

2. 在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的。

3. 如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法。

   ```go
   p.ScaleBy(2)
   ```

4. 我们可以用一个`*Point`这样的接收器来调用Point的方法。

5. 拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。比如time.Duration的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。

## 嵌入结构体扩展类型

