# 函数声明

```go
func name(parameter-list) (result-list) {
    body
}
```

1. 如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。

   ```go
   func f(i, j, k int, s, t string)                 { /* ... */ }
   func f(i int, j int, k int,  s string, t string) { /* ... */ }
   ```

2. 函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。

3. 在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。

4. 实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。

# 多返回值

1. 准确的变量名可以传达函数返回值的含义。

   ```go
   func Size(rect image.Rectangle) (width, height int)
   func Split(path string) (dir, file string)
   func HourMinSec(t time.Time) (hour, minute, second int)
   ```

2. 按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。

3. 如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。

4. 当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。不宜过度使用bare return。

# 错误

1. 将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。
   1. 如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。
   2. 通常，导致失败的原因不止一种，因此，额外的返回值不再是简单的布尔类型，而是error类型。

## 错误处理策略

常用的五种方式。

1. 传播错误。fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。

   ```go
   resp, err := http.Get(url)
   if err != nil{
       return nil, err
   }
   ```

2. 如果错误的发生是偶然性的，或由不可预知的问题导致的。重新尝试失败的操作。

   ```go
   func WaitForServer(url string) error {
       const timeout = 1 * time.Minute
       deadline := time.Now().Add(timeout)
       for tries := 0; time.Now().Before(deadline); tries++ {
           _, err := http.Head(url)
           if err == nil {
               return nil // success
           }
           log.Printf("server not responding (%s);retrying…", err)
           time.Sleep(time.Second << uint(tries)) // exponential back-off
       }
       return fmt.Errorf("server %s failed to respond after %s", url, timeout)
   }
   ```

3. 如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。

   ```go
   if err := WaitForServer(url); err != nil {
       log.Fatalf("Site is down: %v\n", err)
       os.Exit(1)
   }
   ```

4. 有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数。

   ```go
   if err := Ping(); err != nil {
       log.Printf("ping failed: %v; networking disabled",err)
   }
   ```

5. 可以直接忽略掉错误。当你决定忽略某个错误时，你应该清晰地写下你的意图。

## 文件结尾错误

io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在io包中定义。

```go
package io

import "errors"

// EOF is the error returned by Read when no more input is available.
var EOF = errors.New("EOF")
```

