# 基础

1. Go语言的代码通过**包**（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。
2. `main`包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在`main`里的`main` *函数* 也很特殊，它是整个程序执行时的入口。`main`函数所做的事情就是程序做的。

# 程序结构

## 命名

1. Go语言的风格是尽量使用短小的名字。
2. 名字的开头字母的大小写决定了名字在包外的可见性。
3. 包本身的名字一般总是用小写字母。
4. Go语言程序员推荐使用 **驼峰式** 命名，而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为htmlEscape。

## 声明

1. 声明语句定义了程序的各种实体对象以及部分或全部的属性。
2. 每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。
3. 包声明语句之后是import语句导入依赖的其它包。
4. 然后是包一级的类型、变量、常量、函数的声明语句。
5. 包一级的各种类型的声明语句的顺序无关紧要。

## 变量

### 声明语法

```go
var 变量名字 类型 = 表达式
// 一组变量
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

其中 **类型** 或 **= 表达式** 两个部分可以省略其中的一个。

1. 省略类型：根据初始化表达式来推导变量的类型信息。
2. 省略初始化表达式：用**零值**初始化该变量。*零值初始化机制可以确保每个声明的变量总是有一个良好定义的值*。
   1. 数值类型：0。
   2. 布尔类型：false。
   3. 字符串类型：空字符串。
   4. 接口或引用类型（包括slice、指针、map、chan和函数）：nil。
   5. 数组或结构体等聚合类型：每个元素或字段都是对应该类型的零值。

### 简短变量声明

```go
名字 := 表达式
// 一组变量
i, j := 0, 1
```

1. 用于大部分的局部变量的声明和初始化。
2. var形式的声明语句往往是用于：
   1. 需要显式指定变量类型的地方。
   2. 因变量稍后会被重新赋值而初始值无关紧要的地方。
3. 简短变量声明左边的变量可能并非全部都是刚刚声明的。对于已经声明过的，就只有赋值行为了。
4. 简短变量声明语句中必须至少要声明一个新的变量。

### 指针

1. 指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

2. 在Go语言中，返回函数中局部变量的地址也是安全的。

   ```go
   func f() *int {
       v := 1
       return &v
   }
   // 每次调用f函数都将返回不同的结果
   fmt.Println(f() == f()) // "false"
   ```

3. 指针是实现标准库中flag包的关键技术。

### new函数

1. 表达式new(T)将创建一个T类型的匿名变量。初始化为T类型的零值，然后返回变量地址。
2. 每次调用new函数都是返回一个新的变量的地址。

### 生命周期

1. 包一级声明的变量：和整个程序的运行周期是一致的。
2. 局部变量：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。
3. Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？
   1. 从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。
   2. 如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
4. 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这个选择并不是由用var还是new声明变量的方式决定的。

## 赋值

```go
x = 1                       // 命名变量的赋值
*p = true                   // 通过指针间接赋值
person.name = "bob"         // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
v := 1
v++    // 等价方式 v = v + 1；v 变成 2
v--    // 等价方式 v = v - 1；v 变成 1
```

自增和自减是语句，而不是表达式，因此`x = i++`之类的表达式是错误的。

### 元组赋值

1. 对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助。

   ```go
   // 交换两个变量的值
   x, y = y, x
   a[i], a[j] = a[j], a[i]
   ```

2. 可以使一系列琐碎赋值更加紧凑。

   ```go
   i, j, k = 2, 3, 5
   ```

3. 如果表达式太复杂的话，应该尽量避免过度使用元组赋值。

4. 可以用下划线空白标识符`_`来丢弃不需要的值。

### 可赋值性

1. 只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
2. 对于两个值是否可以用`==`或`!=`进行相等比较的能力也和可赋值能力有关系。

## 类型

```go
type 类型名字 底层类型
```

1. 变量或表达式的类型定义了对应存储值的属性特征。

2. 新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

   1. 不可以被相互比较或混在一个表达式运算。

3. 对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型。

   1. 如果T是指针类型，可能会需要用小括弧包装T，比如`(*int)(0)`

4. 比较运算符`==`和`<`也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着**相同底层类型的未命名类型**的值之间做比较。

   1. 如果两个值有着不同的类型，则不能直接进行比较。

   ```go
   var c Celsius
   var f Fahrenheit
   fmt.Println(c == 0)          // "true"
   fmt.Println(f >= 0)          // "true"
   fmt.Println(c == f)          // compile error: type mismatch
   fmt.Println(c == Celsius(f)) // "true"!
   ```

## 包和文件

为了支持模块化、封装、单独编译和代码重用。

如果一个名字是大写字母开头的，那么该名字是导出的。

### 导入包

1. 如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。
2. 导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。

### 包的初始化

1. 包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化。
2. 每个文件都可以包含多个init初始化函数。

## 作用域

1. 不要将作用域和生命周期混为一谈。
   1. 声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。
   2. 一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。
2. 句法块内部声明的名字是无法被外部块访问的。*由花括弧所包含的一系列语句*
3. 声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。
4. 控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。

# 基础数据类型

## 整形

1. Unicode字符`rune`类型是和`int32`等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。
2. 同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
3. 整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。
4. 浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。

## 浮点数

1. 正无穷大`+Inf`和负无穷大`-Inf`，分别用于表示太大溢出的数字和除零的结果；
2. NaN非数，一般用于表示无效的除法操作结果`0/0`或`Sqrt(-1)`。
3. 函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。

## 复数

1. 复数类型：complex64和complex128：对应float32和float64两种浮点数精度。
2. complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部。

变量声明

```go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
real(x*y) // 获取实部
imag(x*y) // 获取虚部
x := 1 + 2i
y := 3 + 4i
```

## 布尔型

1. `&&`的优先级比`||`高（助记：`&&`对应逻辑乘法，`||`对应逻辑加法，乘法比加法优先级要高）。

   ```go
   if 'a' <= c && c <= 'z' ||
       'A' <= c && c <= 'Z' ||
       '0' <= c && c <= '9' {
       // ...ASCII letter or digit...
   }
   ```

2. 布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换。

## 字符串

1. len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i< len(s)条件约束。访问超出字符串索引范围的字节将会导致panic异常。

2. `+` 操作符将两个字符串连接构造一个新字符串。

3. 字符串的值是不可变的。

   ```GO
   s[0] = 'L' // compile error: cannot assign to s[0] 非法
   ```

### 字符串面值

```go
"Hello, 世界"
```

#### 原生字符串面值

```go
const GoUsage = `Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...`
```

1. 使用反引号代替双引号。
2. 用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。

### 字符串和Byte切片

1. strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
2. unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。