# 关系查询处理和优化

## 查询处理步骤

查询分析、查询检查、查询优化、查询执行

### 查询执行

#### 选择

##### 简单全表扫描

1. 已知：内存M块、表有N块。`N = 数据条数 / 每块能放的条数`
2. 从表中读M块，从硬盘 ➞ 内存。
3. 检查内存中的每个元组t，如果t满足条件，输出t。
4. 2、3步骤执行 `N/ M[⨅]` 次

##### 索引扫描

1. 分别扫秒索引，找出各自符合条件的元组指针，取指针交集。
2. 拿指针取表中读取数据块。
3. 检查内存中的每个元组t，如果t满足条件，输出t。

#### 连接

##### 嵌套循环

```c
for (i = 0; i < 大表长度; i++) {
	for (j = 0; j < 小表长度; j++) {
		if (满足连接条件) {
			连接结果放入结果集;
		}
	}
}
```

##### 排序-合并

```c
sort(大表)
sort(小表)
i = j = 0;
while (i < 小表长度)
	if (i.连接属性 > j.连接属性) {
		j++;
	} elseif (i.连接属性 == j.连接属性) {
		连接结果放入结果集;
		j++;
	} else {
		i++
	}
}
```

##### 索引连接【index join】

1. 遍历没有索引的表。
2. 每个元组取有索引的表中，通过索引查找。
3. 连接结果放入结果集。

##### 哈希连接【hash join】

1. 先把小表使用hash函数，放入桶中。
2. 大表用相同的hash函数，去桶中匹配。
3. 连接结果放入结果集。

#### 笛卡尔积读取块数计算

1. 已知：内存M块、A表有N块。B表P块。N > P
2. 笛卡尔积
   1. 读出：从硬盘 ➞ 内存的块数：N + (N / (M - 1)) * P。
   2. 写入：从内存 ➞ 硬盘的块数：A表条数 * B表条数 / 连接后每块能放的条数。
3. 选择
   1. 读出：从硬盘 ➞ 内存的块数：A表条数 * B表条数 / 连接后每块能放的条数。
   2. 写入：筛选后，多的写入，少的留在内存。
4. 投影
   1. [读出：从硬盘 ➞ 内存的块数]
   2. 输出结果。

### 查询优化

#### 优化树优化

1. 把sql语句转化成查询树图。
2. 转成关系代数语法树。
3. 选择尽可能移动到叶端。
4. 把选择和笛卡尔积结合变成一个连接。
5. 投影向上，移到选择和投影同时做为止。

# 数据库恢复

恢复子系统是数据库管理系统一个重要组成部分，常常占整个系统代码的10%以上

## 事务

用户定义的一个数据库的操作序列，这些操作要么都做，要么都不做。

### 语句

1. `begin transaction` 开始

2. `commit` 正常提交

3. `rollback`  运行过程中发生故障 回滚

### ACID

1. `原子性`：事务中包括的所有操作，要么都做，要么都不做

2. `一致性`：是数据库从一个一致性状态到另一个一致性状态，一致性与原子性密切相关，例如银行汇款业务

3. `隔离性`：事务之间不能互相干扰

4. `持续性`：永久性，事务一旦提交就会落盘

#### ACID的破坏因素

1. 多个`事务并行`，不同的事务交叉执行。
2. 事务在运行过程中被强行停止。

## 故障的种类

### 事务内部故障

1. 发生原因：运算溢出、并发事务发生死锁。

2. 处理策略： **事务撤销** `UNDO`。

#### 解决方法

1. 反向扫描日志文件。

2. 对该事务的更新操作执行逆操作，将更新前的值写入数据库。

3. 继续反向扫描日志文件，查找该事务的其他更新操作。

4. 直至找到开始标记。

### 系统故障`软故障`

1. 造成问题：数据不一致、锁紊乱。但不破坏数据库。

2. 类型：CPU故障、操作系统故障、代码错误、系统掉电。

#### 解决方法

1. 正描日志文件，已经提交放入`REDO LIST`，未完成的放入`UNDO LIST`。

   - `REDO LIST`的事务重做：正描日志文件，把更新后的值写入数据库。

   - `UNDO LIST`的事务撤销：反描日志文件，把更新前的值写入数据库。

### 介质故障`硬故障`

造成后果：可能破坏数据库、影响事务。

发生原因：指硬盘损坏、磁头碰撞等、强磁场干扰。

处理策略：重装数据库、重做已完成的事务。

```
1. 装入最新的数据库后备副本。
2. 装入相应的日志文件副本。
```

### 计算机病毒

人为的故障破坏

## 恢复技术

### 数据转储

| 存储方式 | 要求                                                        |
| -------- | ----------------------------------------------------------- |
| 静态转储 | 备份时不允许操作事务。                                      |
| 动态转储 | 1. 备份时允许操作事务。<br>2. 转储期间的事务记在日志文件。  |
| 海量转储 | 每次转储全部数据库                                          |
| 增量转储 | 1. 只转储上一次转储后的更新部分<br/>2. 增量存储记录日志文件 |

|      | 静态                                                     | 动态                                                 |
| ---- | -------------------------------------------------------- | ---------------------------------------------------- |
| 海量 | 每次转储全部数据库<br>转储过程中无运行的事务             | 每次转储全部数据库<br>转储与事务运行并行             |
| 增量 | 只转储上一次转储后更新的过部分<br>转储过程中无运行的事务 | 只转储上一次转储后更新的过部分<br>转储与事务运行并行 |



### 登记日志文件

1. 动态转储必须建立日志文件。
2. 静态转储也可建立日志文件。

#### 内容

1. `日志文件的内容`：记录各个事务对数据库的更新操作、开始标记（begin）、结束标记（commit或rollback）
2. `以记录为单位的日志记录`：事务标识、操作类型、操作对象、更新前数据的旧值、更新后数据的新值
3. `以数据块为单位的日志记录`：事务标识、被更新的数据块
4. `格式`：以记录为单位或以数据块为单位
5. `遵循的规则`
   1. 登记次序按照并发事务执行次序。
   2. 先写日志，后写数据库。

## 具有检查点的恢复技术

1. 重新开始文件【新文件】。
2. 检查点记录【旧文件】：正在执行中的事务的列表。

### 检查点记录内容

1. 建立检查点时刻所有正在执行的事务
2. 这些事务最近一个日志记录里的地址

### 检查点建立过程

1. 当前日志落盘。
2. 日志文件写入**检查点记录**。
3. 数据落盘。
4. **检查点记录**在日志文件中地址写入**重新开始文件**

### 数据恢复步骤

1. 根据**重新开始文件**找到检查点记录。
2. 把正在`执行中的事务`暂时放入`UODO LIST`。
3. 从检查点开始扫描。
   1. 新开始事务：暂放`UODO LIST`。
   2. 事务提交：从`UODO LIST`放入`REDO LIST`。
   3. 扫描结束：`UODO LIST`执行撤销，`REDO LIST`执行重做。

### 数据库镜像

数据库主库同步至镜像。

### 主库

更新操作，同步镜像。

### 镜像`从库`

查询操作，用于主库故障时恢复。

# 并发控制

## 并发

多个事务同时操作一个数据。

### 并发产生的问题

1. `丢失修改`：一个事务的修改覆盖了另一个事务的修改。
2. `不可重复读`：一个事务内，对数据的两次读取得到的结果不一样。
3. `幻读`：在一个事务内，两次获取的记录条数不一样。
4. `脏读`：一个事务中读到了另一个事务要回滚的修改。

## 封锁

1. 排他锁 `写锁` `X`

2. 共享锁 `读锁` `S`

|      | X    | S    | -    |
| ---- | ---- | ---- | ---- |
| X    | Y    | N    | Y    |
| S    | N    | N    | Y    |
| -    | Y    | Y    | Y    |

### 封锁协议

| 协议等级 | 加锁内容   | 加锁时机                            | 释放时机                                   | 解决问题                        |
| -------- | ---------- | ----------------------------------- | ------------------------------------------ | ------------------------------- |
| 一级协议 | 写锁       | 写锁：数据修改前                    | 事务结束后                                 | 丢失修改                        |
| 二级协议 | 写锁、读锁 | 读锁：读数据前<br>写锁：数据修改前  | 读锁：读完数据立即释放<br>写锁：事务结束后 | 丢失修改<br>脏读                |
| 三级协议 | 写锁、读锁 | 读锁：读数据前<br/>写锁：数据修改前 | 读锁：事务结束后<br/>写锁：事务结束后      | 丢失修改<br/>脏读<br>不可重复读 |

### 封锁力度

1. 封锁对象的大小称为封锁力度。

2. 并发度和封锁力度成负相关。
3. 多力度封锁：一个系统中可以同时存在多种封锁力度。

#### 多力度树

根据封锁力度划分层级形成的树。

#### 多力度封锁协议

1. 多力度树中每个结点都可独立加锁。
2. 当一个结点被显示加锁，其后裔结点会被隐式封锁。

### 封锁对象

#### 逻辑单元

   属性值。属性值的的集合。元组。关系。索引项。索引。数据库。

#### 物理单元

​    页。物理记录。

### 活锁与死锁

#### 活锁

1. 产生原因：极端情况下，一个事务长时间无法抢到锁。
2. 解决方法：排队上锁（先来先服务）。

#### 死锁（不是并发带来的问题）

1. 产生原因：两个事务互相等待对方释放锁。

2. 预防方法：

   1. `一次封锁法`：事务开始时，将用到的锁全部加上。
   2. `顺序封锁法`：事务中对加锁对象排序，加锁时要加排在该锁前面的所有锁。

3. 诊断方法：

   1. `超时法`：等待时间超过规定时间。
   2. `等待图法`：周期性生成并检测等待图是否有环。

4. 解决方法：

   找撤销代价最小的事务，将其撤销。

## 并发调度

#### **可串行化**

多个并发执行的结果与某一次序串行结果一致，即为可串行化调度。

#### 冲突可串行化

交换两个事务中不冲突的操作得到新调度序列，若该调度是可串行化的，则原调度是冲突可串行化调度。冲突可是可，反之不成立

#### 两段锁协议

加锁动作和解锁动作不交叉。

1. 冲突可串行化是可串行化调度的充分非必要条件。
2. 遵循两段锁协议是可串行化调度的充分非必要条件。

## 锁的粒度

<img src="/Users/sunchen/Library/Application Support/typora-user-images/image-20210322150711104.png" alt="image-20210322150711104" style="zoom:67%;" />

