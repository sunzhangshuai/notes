# 数据库概念

## 数据

描述事务的符号记录

## 数据库 `DB` 

存储数据的仓库

## 数据库管理系统 `DBMS` 

管理数据库的系统

### 功能

1. 数据定义功能（DDL）
2. 数据操纵功能（DML）
3. 数据组织、存储、管理（通过索引提高存取效率）
4. 数据库的事务管理和运行管理
5. 数据库的建立和维护
6. 其他功能（网络通信）

## 数据库系统

数据库系统由数据、数据库、数据库管理系统、DBA、应用程序、用户组成

### 特点

1. 数据结构化
2. 数据共享度高、冗余度低、易扩充
3. 数据独立性高（物理独立性和逻辑独立性由二级映像实现）
   - 物理独立性：应用程序与数据的物理存储相互独立
   - 逻辑独立性：应用程序与数据的逻辑结构相互独立
4. 数据由数据库管理系统统一管理
   - 安全性保护、完整性检查、并发控制、数据库恢复

## 数据模型

用来描述数据、组织数据、操作数剧

### 三要素

数据结构、数据操作、完整性约束条件

### 概念模型 `信息模型`

用于数据库设计，从用户角度出发      联系：一对一、一对多、多对多。

### 逻辑模型

#### 层次模型

1. 优点：结构清晰、查询效率高

2. 缺点：和现实差距大、插入和删除复杂、查询必须经过双亲

#### 网状模型

1. 优点：和现实相符

2.  缺点：结构复杂

#### 关系模型

1. 优点：概念单一、结构清晰、数据独立性高、安全

##### 概念

域：一组具有相同数据类型的值的集合

##### 三级模式

1. 模式 `逻辑模式` `DDL` ：一个数据库只有一个模式；全局逻辑结构

2. 外模式 `子模式` `用户模式` `DDL`：一个数据库有多个模式；局部逻辑结构

3. 内模式 `存储模式`：一个数据库只有一个内模式；物理结构和存储结构

##### 二级映像

1. 外模式/模式映像：保证数据逻辑独立性

2. 模式/内模式映像：保证数据物理独立性

### 物理模型

数据在磁盘的存取方式

# 关系数据库

## 关系数据结构

#### 笛卡尔积

$$
D₁×D₂×…×D𝑛 = \{(d₁,d₂,…,d𝑛) | d𝒾∈D𝒾, i = 1,2,…,n\}
$$

#### 关系

```
笛卡尔积的子集。
```

$$
R(D₁,D₂,…,D𝑛)
$$

1. 基本表：实际存在的表，即关系。

2. 视图表：从基本表或者其他视图表中导出的表。

3. 查询表：查询结果的表。

#### 关系模式

$$
R(U, DOM, F, D)
$$

1. R是关系名。
2. U是属性名集合。
3. D是属性U中所来自的域。
4. DOM是属性名到域的映像集合。
5. F是属性间数据的依赖关系集合。

#### 关系数据库

多个关系模式在某一时刻对应的关系的集合，称为关系数据库

1. 型：关系数据库模式，多个关系模式的集合。

2. 值：属于多个关系模式的关系的集合。

## 关系操作

1. 操作的的对象和关系都是集合。
2. 分为两类：DQL、DML。

### 关系代数

```
抽象查询语言，用对关系的运算来表达查询。
```

#### 定义

1. 目【度】：列的个数。

2. 象集：R中属性组X的值x的所有元组在Z上的分量的集合，称为X在R中的象集 𝑍𝔁。

3. 悬浮元组：参与连接的两个关系，通过公共属性链接，在其中一个关系上有，另一个关系上没有的元组。

#### 集合运算

1. 并、差、交

$$
R∪S、R-S、R∩S
$$

2. 笛卡尔积
   $$
   R×S
   $$
   

   1. 总目数： m+n
   2. 总元组数： k1 * k2。

#### 关系运算

1. 选择

$$
𝛔𝐹(R), F=A𝜽B
$$

2. 投影
   $$
   ∏𝑨(R)
   $$
   

   1. 只包含投影列的元组去重。

3. 连接
   $$
   R⋈S, F=A𝜽B
   $$

   1. 内连接

      1. 等值连接
         1. 连接条件：连接符必须是=。
      2. 自然连接
         1. 没有连接条件。
         2. 去掉重复列。
         3. 默认连接条件：所有重复的列均需要相等。

   2. 外连接：保留悬浮元组。

      1. 左外连接：保留左边关系的悬浮元组。
         $$
         R⋊S
         $$

      2. 右外连接：保留右边关系的悬浮元组。
         $$
         R⋉S
         $$
         

4. 除运算
   $$
   R÷S
   $$

   1. R(X,Z),   S(Z,Y)
   2. Z为公共属性。
   3. 值域Dz为S在Z上的投影。
   4. 筛选象集𝑍𝔁包含Dz的所有X元组。

##### 除法关键字

全部、至少、所有

# SQL

关系数据库语言

## 特点

1. 综合统一：语言风格统一。
   1. 数据定义语言 `DDL`：定义表、模式、视图、索引。
   2. 数据操纵语言 `DML`：对表、视图中的数据的增删改。
   3. 数据控制语言 `DCL`：安全性、`revoke`，`grant`。
   4. 数据查询语言 `DQL`
   5. 数据库重构和维护。
   6. 完整性约束、事务。
   7. 嵌入式SQL和SQL定义。
2. 高度非过程化：面向对象、提高独立性。【映像】
3. 面向集合操作。
4. 以固定语法可嵌入多种高级语言。
5. 语言简洁、易学易用。

## 基本概念

1. 外模式：视图、权限。
2. 模式：基本表。
3. 内模式：存储文件、索引。

## DDL

### 模式

#### 定义

```
create schema <模式名> authoruzation <用户名>
```

#### 删除

```
drop schema <模式名> <cascade|restrict>
```

1. cascade：删除相关依赖对象
2. restrict：有依赖就拒绝

### 基本表

#### 定义

```
create table [模式名.]<表名> (
	<列名> <数据类型> [列级完整性约束条件]
	[, <列名> <数据类型> [列级完整性约束条件]]
	...
	[, <表级约束性条件>]
)
```

#### 删除

```
drop table [模式名.]<表名> <cascade|restrict>
```

1. cascade：删除相关依赖对象
2. Restrict：有依赖对象就拒绝
3. 依赖对象：外码、check、视图、触发器、存储过程、函数

#### 修改

```
alter table <表名>
[add [column] <新列名> <数据类型> [完整性约束条件]]
[add <表级完整性约束>]
[drop [column] <列名> [cascade|restrice]]
[drop constraint <完整性约束名> [cascade|restrice]]
[alter column <新列名> <数据类型>]
```

### 索引

1. B+树索引：叶结点属性和元组指针。
2. 散列索引：建立若干桶，桶中存放属性和元组指针。
3. 位图索引：

#### 定义

```
create [unque] [cluster] index <索引名>
on <表名>(<列名> [<次序> [, <列名> [<次序>] ...]])
```

#### 删除

```
drop index <索引名>
```

同时删除数据字典对索引的描述。

#### 修改

```
alter index <旧索引名> rename to <新索引名>
```

### 视图

#### 定义

```
create view <视图名> [(<列名> [, <列名> ...)]]
as <子查询>
[with check option]
```

1. `with check option`：操作时，要满足子查询中的条件表达式。
2. 列名必须全部指定或全部省略。

#### 不可更新的视图（不可和不允许概念不同）

1. 由两个或两个以上表导出的
2. 视图来自常数或表达式 只允许DELETE
3. 聚集函数
4. group by    DISTINCT
5. 有嵌套查询

#### 删除

```
drop view <视图名> [cascade]
```

#### 查询

1. 视图消解：结合子查询和用户查询，转换成等价的对基本表的查询。

#### 更新todo

#### 作用

1. 简化用户的操作。
2. 用户以多种角度看待同一数据。
3. 对重构数据库提供了一定的逻辑独立性。
4. 对机密数据提供安全保护。
5. 可以更清晰的表达查询。

### 数据字典

关系模式定义、视图定义、索引定义、完整性约束定义、用户的操作权限、统计信息。

## DQL

### 定义

```
select [all|distinct] <目标列表达式> [, <目标列表达式>] ...
from <表名或视图名> [, <表名或视图名>...] | (<select 语句>) [AS] <别名>
[where <条件表达式>]
[group by <列名1> [having <条件表达式>]]
[order by <列名2> [asc|desc]]
```

### 条件表达式

1. `between ... and ...` 前闭后闭
2. `like`
   1. `%`：任意长度字符。
   2. `_`：任意一位字符。
   3. `escape`：转义字符。
      1. 用 `escape` 定义转移码。
      2. 转移码之后的字符不具有转义含义。

### 聚合函数

1. `count(列名)`：  跳过空值。
2. 其他聚合函数：跳过空值。

### GROUP BY

1. 只能用于 `select` `having`。
2. 后面可加多列。
3. 一个查询中同时存在 `group by` 和 `order by` 时
   1. 先执行 `group by` ， 再  `order by` 
   2. 可使用嵌套查询，使  `order by`  提前。

### where子句和having的区别

1. where作用域：基本表和视图。
2. having作用域：组。

### 连接查询

1. 等值连接、非等值连接：连接域相等。
2. 自身连接：参与连接的表都是同一张表。
3. 外连接

4. 多表连接

### 嵌套查询

一个查询嵌套在另一个查询块内。

1. 父查询：上 `外` 层查询
2. 子查询：下 `内` 层查询

3. 不相关子查询：子查询的查询条件不依赖父查询。

4. 相关子查询：子查询的查询条件依赖父查询。
   1. 查询过程：可参照嵌套查询。

#### 结果集要求

1. in：多行一列。
2. 比较：一行一列 `分量`。
3. any `some` 和all：多行一列。
   1. any：`> any ()` 大于最小值。` < any()` 小于最大值。
   2. all：`> all ()` 大于最大值。`< all()` 小于最小值。
4. exist：一行多列。
5. exists：多行多列。

### 集合查询

结构相同

1. 并：`union`
2. 交：`intersect`
3. 差：`except`

## DML

### 插入

```
insert
into <表名> [(<属性列1>[,<属性列2>]...)]
values (<常量1>[,常量2])[,(<常量1>[,常量2])]...;
```

#### 插入子查询结果

```
insert
into <表名> [(<属性列1>[,<属性列2>]...)]
子查询;
```

### 修改

```
update <表名>
set <列名> = <表达式> [, <列名> = <表达式>] ...
[where <条件>];
```

### 删除

```
delete from <表名>
[where <条件>];
```

## 空值

1. 判断：`is null` `is not null`

2. 约束条件：码、定义`not null`、定义 `unique` 不能取空值。

3. 运算

   1. 空值与任何值的算数运算：`3 + null = null`
   2. 空值与任何值的比较运算：`3 < null = unknown`，只有选择条件为`true`结果会输出。
   3. unknown与任何值的逻辑运算 ，`and`向下，`or`向上。
      1. true
      2. unknown
      3. false

   | 操作 | true    | false   | unknown |
   | ---- | ------- | ------- | ------- |
   | AND  | unknown | false   | unknown |
   | OR   | true    | unknown | unknown |
   | NOT  |         |         | unknown |

# 数据库完整性

## 实体完整性

primary key

要求：不能为空、唯一。

## 参照完整性

foreign key

```
foreign key (本表属性名) references 被参照表(主码)
on [delete cascade| update cascade | delete no action]
```

1. delete cascade：主表删，本表相应元组删除。
2. update cascade：主表更新，本表相应元组更新。
3. delete no action：不允许主表删除。

## 用户定义完整性

### 属性上的约束条件

#### 不允许空值。

not null

#### 列值唯一。

unique

#### check短语

1. 列级

```
<列名> <数据类型> check (<列名> [in|between|=] 表达式)
```

2. 表级

```
...属新定义
check (<列名1> [in|between|=] 表达式 [and|or] <列名....>)
```

### 完整性约束命名字句

#### 定义

```
constraint <完整性约束条件名> <完整性约束条件>
```

1. 完整性约束条件名：自定义的一个名字，类比索引名。
2. 完整性约束条件：not null、unique、check短语、primary key、foreign key。

#### 修改

1. 删除

```
alter table <表名> drop constraint <完整性约束条件名>
```

2. 添加

```
alter table <表名> add constraint <完整性约束条件名> <完整性约束条件>
```

## 触发器

1. 只有表的拥有者，才能创建触发器。

### 定义

```
cearte trigger <触发器名>
{before|after <触发事件> on <表名>}
referencing new|old row as <变量>
for each <触发器类型>
[when <触发条件>] <触发动作体>
```

1. 触发事件：insert、update、update or insert、update of 列名。
2. referencing：new row as new，old row as old。
3. 触发器类型
   1. row：行级、每行触发一次。
   2. statement：语句级、一条语句引发多行变化，这些变化只触发一次。
4. 触发条件：列名 <比较运算赋> 表达式。
5. 触发动作体：存储过程

```
declare
变量名 类型;
...
begin
	if 条件表达式[变量名 is [not] null] then
		select 类名 into 变量名 ...;
	end if;
end;
```

### 激活

1. 先执行该表的before触发器。
2. 执行sql语句。
3. 执行该表的after触发器。

### 删除

```
drop trigger <触发器名> on <表名> 
```

