# 数据库关系规范化理论

## 数据依赖

### 函数依赖

设：属性集`U`，关系模式`R(U)`，`r`为`R(U)`中的任意一个关系。`X`,`Y`是`U`的子集。

```
1. r中任意两个元组，在X上的属性值相同时，在Y上的属性值一定相同。
2. X函数确定Y。Y函数依赖于X。
```

$$
X → Y
$$

#### 性质

1. 非平凡的函数依赖

```
1. X → Y, 
2. Y ⊈ X
```

2. 平凡的函数依赖

```
1. X → Y, 
2. Y ⊆ X
```

3. 完全函数依赖

```
1. X → Y, 
2. X的任何一个真子集都不能决定Y
```

$$
【X→🅕Y】
$$

4. 部分函数依赖

```
1. X → Y, 
2. X中有真子集可以决定Y
```

$$
【X→🅟Y】
$$

5. 传递函数依赖

```
1. X → Y，
2. Y ⊈ X, 
3. Y ↛ X,
4. Y → Z
```

$$
【X→传递Y】
$$

#### Eg

关系模式R(SNO, SNAME, CNO, GRADE)。当SNO相同时，SNAME一定相同。

#### 注意事项

任意两个元组，在X上的属性值不同时，在Y上的属性值可能相同。

### 多值依赖

## 码

```
可以唯一确定一个元组的属性组。
```

设：K是关系R<U, F>上的一个属性组合

1. 候选码

```
K →🅕 U
```

2. 主码：从候选码中选一个作为主码。

3. 超码包含候选码的属性组称为超码。

```
K → U
```

4. 主属性：候选码的任意一个属性。

5. 非主[码]属性：不包含在任何候选码中的属性。

6. 全码：一个关系的整个属性组是码。

7. 外码

```
1. X非R的码。
2. X是另一个关系的码。
```

## 范式

范式主要解决的问题：

1. 插入异常。
2. 删除异常。
3. 修改复杂【冗余】。

设：关系R<U, F>

### 1NF

每一个分量都是原子【不可分】的。

### 2NF

1. R ∈ 1NF。
2. 非主属性完全依赖于任何一个码。

### 3NF

1. R ∈ 1NF。
2. 每个非主属性，都有对码的直接依赖。

#### 证明3NF属于2NF

```
设：(X,Y)是码,Z是非主属性。
如不满足2NF，设：Y→Z。
则推出：(X,Y)→🅟Y，Y→Z。故推出(X,Y)→传递Z，不符合3NF。
```

### BCNF

1. R ∈ 1NF。
2. 对于所有的非平凡函数依赖。
3. 任意一个决定因素必包含码。

#### 证明BCNF属于3NF

```
对于任意的非主属性。
1. 部分依赖：会出现决定因素不含码。
2. 传递依赖：会出现决定因素不含码。
```

#### 证明BCNF消除了主属性对不包含它的码的传递依赖和部分依赖

##### 部分依赖

```
部分依赖的本意就是决定因素是码的真子集。
有部分依赖则表明: 存在决定因素不包含码。
不符合定义。
```

##### 传递依赖

```
传递依赖为：(X,Y)是码, Z非码，并有(X,Y)→Z, Z→（任意属性）
此时，Z是决定因素，但Z不包含码。
不符合定义。
```

### 4NF

### eg

```
S-L-C(SNO, SDEPT, SLOC, CNO, GRADE)                      // 1NF
S-C(SNO, CNO, GRADE), S-L(SNO, SDEPT, SLOC)              // 2NF
S-C(SNO, CNO, GRADE), S-D(SNO, SDEPT), D-L(SDEPT, SLOC)  // 3NF
S-C-T(SNO, CNO, TNO)	//一个老师只能上一门课								// 3NF
S-C(SNO, CNO), T-C(TNO, CNO)														 // BCNF
```

## Armstrong公理系统

### 基本概念

#### 逻辑蕴含

在关系模式R<U,F>中，对于每一个关系r，`X ➝ Y` 都成立，就说`F`逻辑蕴含`X ➝ Y`。

#### 闭包

1. 在关系模式R<U,F>中，F所蕴含的函数依赖的全体叫做`F`的闭包。
2. 由属性组`X`和其能导出的所有属性`Y`的集合`XY`，称为属性集`X`关于函数依赖集`F`的闭包`X🅵⁺`

#### 最小依赖集

1. 右部仅有一个属性。
2. 不存在 `X ➝ A`，使F和`F -  X ➝ A` 等价。
3. 不存在部分依赖。

### 求X在F上闭包

1. 求X中属性能推导出的所有属性的集合B。
2. 判断`X ∪ B` 是否相等。
   1. `X ∪ B` 与`U`相等：算法终止。
   2. `X` 与`X ∪ B` 相等：算法终止。
   3. 不相等：继续下一轮循环。

## 模式分解

### 基本概念

#### 定义

##### 无损连接性

自然连接结果和原来的结果保持一致。

##### 保持函数依赖

分解后的结果要保持原来的函数依赖，否则会出现更新复杂、插入异常。

#### F在属性U𝑖上的投影

$$
\{X ➝ Y | X ➝ Y∊ F⁺ ∧ XY ⊆ U𝑖\}
$$

### 判别保持函数依赖

1. 求`F`在各个子关系的上投影。
2. `F'`为所有投影的并集。
3. 判断F和F'
   1. 相同：保持函数依赖。
   2. 不相同：判断`F'`是否能推出`F-F'`。
      1. 能推出：保持。
      2. 否则：不保持。

### 判别无损连接性

1. 建一个m行j列的表格，j为属性、m为关系。关系如图：

   | 列：关系、行：属性 | A    | B    | C    | D    |
   | ------------------ | ---- | ---- | ---- | ---- |
   | AB                 | a₁   | a₂   | b₁₃  | b₁₄  |
   | BC                 | b₂₁  | a₂   | a₃   | b₂₄  |
   | CD                 | b₃₁  | b₃₂  | a₃   | a₄   |

2. 第一次遍历原函数依赖集`F`。

3. 在表格中找函数依赖左边属性在表格中相同的行。将右边的值改为相同值：

   1. 如果有a：全部改为a。
   2. 否则：改为b的行下标最小的那个。

4. 查看此次遍历结果否对表格有修改，进行判断：

   1. 如果有某一行全是a：判定`无损函数依赖`，结束。
   2. 如果没有对表格修改：判定`有损函数依赖`，结束。
   3. 对表格有修改：进行下一次遍历。

### 最小函数依赖算法

1. 先把依赖的右边分解：`A ➝ BC ⟹ A ➝ B, A ➝ C`。
2. 遍历每一个函数依赖，尝试删除当前函数依赖 `eg：A ➝ B`。
3. 判断由剩下的函数依赖是否可推出`A ➝ B` （或判断 由剩下的函数依赖算出的 `A𝚏⁺` 是否包含 B）。
4. 若可推出，删除该函数依赖，否则，保留该函数依赖。
5. 最后剩下的就是最小函数依赖。

### 候选码算法

1. 求最小函数依赖集`F`
2. 求属性组：`L`,`R`,`LR`,`N`。
   1. `L`：只在所有函数依赖的左边出现。
   2. `R`：只在所有函数依赖的右边出现。
   3. `LR`：在所有函数依赖的左右都出现。
   4. `N`：在所有函数依赖的左右都未出现。
3. 判断属性组`L∪N`的闭包是否为`U`。如果为`U`，则`LN`为唯一候选码。
4. 取`LR`中的属性或属性组，与`L∪N`一一组合，计算闭包，闭包为`U`的均为候选码。**要排除超码**

### 模式分解算法

1. 求极小函数依赖集`F'`。
2. 求`U`中不在`F`的属性`U₀ `。
3. 对F中左边相同的分组，每个组中属性合并（`U₁`, `U₂`, `U₃` ...），去掉被别的组包含的`Uᵢ`
4. **保持函数依赖的3NF**（`U₁`, `U₂`, `U₃` ...）
5. 取`R<U, F>`中任一码，属性集合为`U'`
6. **保持函数依赖和无损连接性的3NF**（`U₁`, `U₂`, `U₃` ...）合并`U'`，去掉被包含的组`Uᵢ`。
7. 遍历分解后的关系，判断每一个是否属于BCNF。
8. 关系不属于，找到 `X ➝ A`,`X`非码的函数依赖，将该关系分解成 `S₁`，`S₂`。`S₁ = XA`，`S₂ = U - A`。再判断每个是否属于BCNF。
9. **无损连接性的BCNF** 最后拆解出来的集合（`U₁`, `U₂`, `U₃` ...）

# 数据库编程

## 存储过程

### 变量&常量定义

1. 变量

   ```
   变量名 数据类型 [[not null] := 初值表达式]
   变量名 数据类型 [[not null] 初值表达式]
   ```

2. 常量：程序中不可改变。

   ```
   常量名 数据类型 constant := 常量表达式
   ```

### 流程控制语句

```
if <条件> then
	<sql语句>;
else 
	<sql语句>;
end if;
```

### 循环控制语句

```
loop
	<sql语句>;   // 循环体
	break;
end loop;
```

```
while <条件> loop
	<sql语句>;   // 循环体
end loop;
```

```
for <变量> in [reverse] 下界 .. 上界 loop
	<sql语句>;   // 循环体
end loop;
```

1. 不加reverse：变量 = 下界，变量++，直到变量 =  上界
2. 加reverse：变量 = 上界，变量--，直到变量 =  下界

### 定义

```
create or replace procedure <存储过程名称> (参数名 数据类,...)
as declare
	定义变量|常量;
	...
begin
	语句
	rollback;
	return;
	commit;
end;
```

### 执行

```
call/perform  procedure <存储过程名称> (参数1,....);
```

### 修改

1. 重命名

   ```
   alter procedure <旧存储过程名称> rename to <新存储过程名称>;
   ```

2. 重编译

   ```
   alter procedure <存储过程名称> compile;
   ```

### 删除

```
dorp procedure <存储过程名称>()
```

