# GIT基础

## 版本控制系统

1. 可以将选定的文件回溯到之前的状态；
2. 将整个项目都回退到过去某个时间点的状态；
3. 可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因；
4. 可以看出谁在何时报告了某个功能缺陷等等。

### 本地版本控制系统

采用某种简单的数据库来记录文件的历次更新差异。

RCS

### 集中化版本控制系统

有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 

#### 缺点

1. 中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。
2. 中心数据库所在的磁盘发生损坏，又没有做恰当备份，你将丢失所有数据——包括项目的整个变更历史。

### 分布式版本控制系统

1. 客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 
2. 每一次的克隆操作，实际上都是一次对代码仓库的完整备份。
3. 任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。

## GIT特性

1. **直接记录快照，而非差异比较。**

   ![git快照](imgs/git快照.png)

   1. Git 像是把数据看作是对小型文件系统的一系列快照。
   2. 每当提交更新或保存项目状态时，基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。
   3. 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

2. **近乎所有操作都本地执行**

3. **git保证完整性**

   1. Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 
   2. 不可能在 Git 不知情时更改任何文件内容或目录内容。 
   3. Git 用以计算校验和的机制叫做 SHA-1 散列。这是40个十六进制字符串。
   4. 基于 Git 中**文件的内容或目录结构**计算出来。

4. **git一般只添加数据**

    Git 几乎不会执行任何可能导致文件不可恢复的操作。

5. **git拥有三种状态和三个阶段**

   ![git状态](imgs/git状态.png)

   1. 三种状态
      1. 已修改【modified】：表示修改了文件，但还没保存到数据库中。
      2. 已暂存【staged】：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
      3. 已提交【committed】：表示数据已经安全的保存在本地数据库中。
   2. 三个阶段
      1. 工作区：是对项目的某个版本独立提取出来的内容。从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
      2. 暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 Git 的术语叫做「索引」。
      3. git目录： Git 用来保存项目的元数据和对象数据库的地方。 从其它计算机克隆仓库时，复制的就是这里的数据。 

## GIT初配置

### 查看git版本

```shell
git --version
```

### git config

设置控制 Git 外观和行为的配置变量。

1. `/etc/gitconfig` 文件：包含系统上每一个用户及他们仓库的通用配置。--system 选项会读写该文件中的配置变量。
2. `~/.gitconfig` 或 `~/.config/git/config` 文件：只针对当前用户。--global 选项会读写该文件中的配置变量。
3. 项目中的 ` .git/config` 文件：针对该仓库。 默认用这个。--local。

每个级别会覆盖上一级别的配置。

#### 查看所有配置以及它们所在的文件

```shell
git config --list --show-origin
```

#### 用户信息

1. 必须设置用户名和邮件地址。
2. 会写入到每一次提交中，不可更改。

```shell
# 最小配置
git config [--local|--global|--system] user.name your_name
git config [--local|--global|--system] user.email XXX@XXX.com
```

#### 文本编辑器

当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器【Vim、Emacs、Notepad++】。 

```shell
git config --global core.editor 编辑器
```

#### 检查配置信息

会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置。

```shell
git config --list [--local|--global|--system]

# 检查某一项的配置
git config <key>

# 重复时可以查看是在哪个文件中配置的该项值
git config --show-origin <key>
```

### 获取帮助

```shell
# 等价
git help <verb>
git <verb> --help
man git-<verb>

# e.g. 获取 git config 命令的手册
git help config
```

如果不需要全面的手册，只需要可用选项的快速参考，那么可以用 -h 选项获得更简明的 「help」 输出。e.g.

```shell
git add -h
```

## 获取GIT仓库

### 在已存在目录中初始化仓库

```shell
git init
```

- 将创建一个名为 .git 的子目录。

- 子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 

### 克隆现有的仓库

```shell
git clone <url> [projectName]
```

- Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。
- 默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 

## 记录每次更新到仓库

工作目录下的每一个文件都不外乎两种状态：**已跟踪** 或 **未跟踪**。 

- 已跟踪：被纳入了版本控制的文件，上一次快照中有他们的记录。已跟踪的文件就是 Git 已经知道的文件。包含几个子状态。
  - 未修改「**unmodified**」
  - 已修改「**modified**」
  - 已暂存「**staged**」
- 未跟踪「**untracked**」：除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 

![文件状态周期变化](imgs/文件状态周期变化.png)

### 检查当前文件状态

```shell
git status
```

- `Changes to be committed`：已暂存文件。
- `Changes not staged for commit`：已跟踪文件的内容发生了变化，但还没有放到暂存区。

### 跟踪新文件

```shell
git add <fileName>
```

### 暂存已修改的文件

- 暂存操作会为每一个文件计算校验和，然后会把当前版本的文件快照「 **blob 对象**」保存到 Git 仓库中。
- 最终将校验和加入到暂存区域等待提交。

```shell
git add <fileName>
```

### 状态简览

```shell
git status -s
git status --short
```

输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。

- `??`：新添加的未跟踪文件。
- `A`：新添加到暂存区中的文件。
- `M`：修改过的文件。

### 忽略文件

无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。

```shell
# 创建.gitignore文件
# 子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。
```

#### 格式规范 

- 所有空行或者以 *#* 开头的行都会被 Git 忽略。 
- 可以使用标准的 glob 模式「shell 所使用的简化了的正则表达式」匹配，它会递归地应用在整个工作区中。
  - *****：匹配零个或多个任意字符。
  - **[abc]**：匹配任何一个在方括号中的字符。
  - **?**：只匹配任意一个字符。
  - **[0-9]** ：表示所有在这两个字符范围内的都可以匹配。
  - ******：匹配任意中间目录。
- 以 */* 开头：防止递归。指定文件
- 以 */* 结尾：指定目录。
- 模式前加叹号 *!* ：忽略指定模式以外的文件或目录。

### 查看未暂存的修改

```shell
git diff
```

- 对比未暂存和已暂存。

### 查看已暂存的修改

```shell
git diff --cached
```

- 可以使用 `git difftool` 命令来调用 emerge 或 vimdiff 等软件（包括商业软件）输出 diff 的分析结果。 

- `git difftool --tool-help` ：看系统支持哪些 Git Diff 插件。

- cached 和 staged 是同义词。
- 对比已暂存和未修改。

### 查看任意两个版本之间的修改

```shell
git diff <版本号1> <版本号2>
```

### 查看某文件夹下的修改

```shell
git diff <文件夹>
git diff <版本号1> <版本号2> <文件夹>
```

### 提交更新

- 提交时记录的是放在暂存区域的快照。
- Git 会先计算每一个子目录的校验和， 然后在 Git 仓库中这些校验和保存为**树对象**「**记录着目录结构和 blob 对象索引**」。
- 随后，Git 便会创建一个**提交对象**「**包含树对象的指针和所有提交信息**（作者的姓名和邮箱、提交时输入的信息、指向它的父对象的指针）」。

#### 首次提交

![首次提交](imgs/首次提交.png)

#### 非首次提交

![非首次提交](imgs/非首次提交.png)

```shell
git commit
```

启动你选择的文本编辑器来输入提交说明，编辑器是通过 Shell 的环境变量 EDITOR 指定的，一般为 vim 或 emacs。

```shell
git commit -m "msg"
```

#### 显示格式

[提交分支 提交的 SHA-1 校验和前缀] 提交信息

多少文件修改，多少行添加，多少行删除。

创建了哪些文件。删除了哪些文件。

### 跳过使用暂存区域

```shell
git commit -a
```

### 移除文件

```shell
git rm files 
```

1. 如果在工作目录中删除了文件，需要执行该命令从跟踪清单中删除。**最终生效还需 commit**。

2. 效果：将文件从跟踪清单中删除，并且在工作目录下删除。**最终生效还需 commit。**

3. **注意**：如果该文件在工作目录或者暂存区中做过修改，需要使用 -f 强制删除。

   ```shell
   git rm files -f
   ```

4. files可以使用正则。

   ```shell
   git rm log/\*.log
   git rm \*idea
   ```

```shell
git rm files --cached
```

效果：将文件从跟踪清单中删除，但在工作目录中保留。

### 移动文件

```shell
git mv fileFrom fileTo
```

Git 并不显式跟踪文件移动操作。相当于运行了下面三条命令。

```shell
mv fileFrom fileTo
git rm fileFrom
git add fileTo
```

## 查看提交历史

```shell
git log
```

- 会按时间先后顺序列出所有的提交，最近的更新排在最上面。
- 会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。

### 显示每次提交引入的差异

```shell
git log -p|--patch
```

### 显示每次提交的简略统计

```shell
git log --stat
```

- 列出所有被修改过的文件、有多少文件修改、被修改过的文件删了多少行，加了多少行。 

- 在每次提交的最后还有一个总结。 

### 指定格式展示提交历史

```shell
git log --pretty=[oneline|short|full|fuller]
```

- **oneline**：每个提交放在一行显示。
- **short**：不显示date。
- **full**和**fuller**：多显示一些内容。

```shell
git log --pretty=format:"%h - %an, %ar : %s"
```

| 选项 | 说明                                          |
| :--- | :-------------------------------------------- |
| %H   | 提交的完整hash值                              |
| %h   | 提交的简写哈希值                              |
| %T   | 树的完整哈希值                                |
| %t   | 树的简写哈希值                                |
| %P   | 父提交的完整哈希值                            |
| %p   | 父提交的简写哈希值                            |
| %an  | 作者名字                                      |
| %ae  | 作者的电子邮箱                                |
| %ad  | 作者修订日期（可以用 --date=选项 来定制格式） |
| %ar  | 作者修订日期，按多久以前的方式显示            |
| %cn  | 提交者的名字                                  |
| %ce  | 提交者的电子邮件地址                          |
| %cd  | 提交日期                                      |
| %cr  | 提交日期（距今多长时间）                      |
| %s   | 提交说明                                      |

### 展示分支、合并历史

```shell
git log --graph
```

### 限制输出长度

```shell
git log -<n>
```

| 选项              | 说明                                       |
| ----------------- | ------------------------------------------ |
| -\<n>             | 仅显示最近的 n 条提交。                    |
| --since， --after | 仅显示指定时间之后的提交。                 |
| --until，--before | 仅显示指定时间之前的提交。                 |
| --author          | 仅显示作者匹配指定字符串的提交。           |
| --committer       | 仅显示提交者匹配指定字符串的提交。         |
| --grep            | 仅显示提交说明中包含指定字符串的提交。     |
| -S                | 仅显示添加或删除内容匹配指定字符串的提交。 |

### 查看各分支当前所指的对象

```shell
git log --decorate
```

## 撤销操作

### 修改最后一次提交

```shell
git commit --amend
```

### 取消暂存的文件

```shell
git reset HEAD <file>...
```

### 撤消对文件的修改

```shell
git checkout -- <file>...
```

对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。

## 远程仓库

### 查看远程仓库

```shell
git remote
```

- 会列出你指定的每一个远程服务器的简写。
- origin 是 Git 给你克隆的仓库服务器的默认名字。

```shell
git remote -v
```

显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。

### 添加远程仓库

```shell
 git remote add <shortname> <url>
```

### 从远程仓库中抓取与拉取

```shell
git fetch <remote>
```

*git fetch* 命令只会将数据下载到你的本地仓库。并不会自动合并或修改你当前的工作。

### 推送到远程仓库

```shell
git push <remote> <branch>
```

### 查看某个远程仓库

```shell
git remote show <remote>
```

- 列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。
- 列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了。
- 当你执行 git pull 时哪些本地分支可以与它跟踪的远程分支自动合并。

### 重命名远程仓库

```shell
git remote rename oldName newName
```

### 移除远程仓库

```shell
git remote remove name
```

## 打标签

Git 可以给仓库历史中的某一个提交打上标签，以示重要。

### 列出标签

```shell
git tag
```

以字母顺序列出标签，但是它们显示的顺序并不重要。

```shell
# 通配符 e.g. "v1.8.5*"
git tag -l <通配符>
```

按照通配符列出标签需要 -l 或 --list 选项。

### 创建标签

Git 支持两种标签：轻量标签（**lightweight**）与附注标签（**annotated**）。

#### 附注标签

```shell
git tag -a <标签名> -m "备注"
```

- 存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 
- 通常会建议创建附注标签，这样你可以拥有以上所有信息。

#### 轻量标签

```shell
git tag <标签名>
```

很像一个不会改变的分支——它只是某个特定提交的引用。

#### 对过去的提交打标签

```shell
git tag -a <标签名> <logid>
```

### 查看标签信息和与之对应的提交信息

```shell
git show <标签名>
```

轻量标签无法额外的标签信息。

### 共享标签

```shell
git push <remote> <tagname>
# 并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。
git push <remote> --tags
```

### 删除标签

#### 删除本地仓库上的标签

```shell
git tag -d <tagname>
```

#### 删除远程仓库上的标签

```shell
# 将冒号前面的空值推送到远程标签名，从而高效地删除它
git push <remote> :refs/tags/<tagname>
# 直观删除
git push <remote> --delete <tagname>
```

### 检出标签

如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令。

## GIT别名

```shell
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.unstage 'reset HEAD --'
```

