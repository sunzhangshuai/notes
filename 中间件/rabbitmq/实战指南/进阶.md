

# 备份交换器【Alternate Exchange】

## 使用场景

1. 当 `mandatory` 为false时，不会将未匹配到的消息返回给生产者，此时可使用备份交换器。
2. 当使用备份交换器时，`mandatory` 参数不生效。

## 使用方式

1. ```java
   args.put("alternate-exchange", "备份交换器名称");
   // 声明主交换器时将参数传入
   ```

2. ```sh
   rabbitmqctl set_policy AE "^主交换器名称$" `{"alternate-exchange": "备份交换器名称"}`
   ```

## 注意事项

1. 备份交换器最好设置为**fanout**类型。
2. 消息被发送到备份交换器时的路由键和从生产者发出的路由键是一样的。

## 特殊情况

1. **备份交换器不存在**，客户端、服务端不会出现异常，消息丢失。
2. **备份交换器没有绑定任何队列**，客户端、服务端不会出现异常，消息丢失。
3. **备份交换器没有任何匹配的队列**，客户端、服务端不会出现异常，消息丢失。
4. 备份交换器和 `mandatory` **一起使用**， `mandatory` 参数无效。

# 过期时间【TTL】

## 消息

### 队列中设置

1. 声明队列时设置。

   ```java
   args.put("x-message-ttl",6000);
   ```

2. 命令行设置。

   ```sh
   rabbitmqctl set_policy TTL ".*" '{"message-ttl": 60000}' --apply-to queueName
   ```

3. API设置。

   ```shell
   curl -i -u root:root -H "content-type:application/json" -X PUT -d '{"auto_delete":flase, "durable": true, "argument": {"x-message-ttl",6000}}' http://localhost:15672/api/queues/{vhost}/{queueName}
   ```

4. 消息过期时会立马从队列中删除。

5. 若果ttl为0，表示需要被立即消费，否则被丢弃，可配合死信队列使用。

### 消息中设置

1. 发送消息时设置。

   ```java
   new AMQP.BasicProperties().builder().expiration("6000").build(),
   ```

2. API设置。

   ```shell
   curl -i -u root:root -H "content-type:application/json" -X PUT -d '{"properties": {"expiration": "60000"}, "routing_key": "keyName"}' http://localhost:15672/api/exchanges/{vhost}/{exchangesname}/publish
   ```

3. 不会立马从队列中删除，在即将投递给消费者之前判断。

## 队列

声明队列时设置。

```java
args.put("x-expires", 18000);
```

含义为：在过期时间呢没有被使用过的队列就删除。

# 死信队列【Dead-Letter-Exchange】

当消息在一个队列中变成死信之后，能被重新发送到另一个交换器，这个交换器就是`DLX`。绑定`DLX`的队列就称为死信队列。

## 消息死信队列的情况

1. 消息被拒绝，并且 requeue参数为false。
2. 消息过期。
3. 队列达到最大长度。

将死信队列和正常队列的ttl设置为0，可以替代`immediate`参数的功能。

## 设置方式

1. 声明队列时设置。

   ```java
   args.put("x-dead-letter-exchange", exchangeName);
   ```

2. 命令行设置。

   ```sh
   rabbitmqctl set_policy DLX ".*" '{"dead-letter-exchange": "死信交换器名称"}' --apply-to queues
   ```

3. 发到死信交换器的routing-key沿用正常队列的，也可手动指定。

   ```java
   args.put("x-dead-letter-routing-key", Config.dxRoutingKey);
   ```

## 适用场景

1. 延时队列。
2. 通过分析消费死信队列中的消息来分析异常情况，改善系统状态。

# 延时队列

通过死信队列 + 过期时间可实现延时功能。

## 使用场景

1. 订单15分钟未支付过期。
2. 对消息指定时间处理。

# 优先级队列

1. 设置队列的最大优先级。

   ```java
   param.put("x-max-priority", maxPriority);
   ```

2. 投递消息时设置消息优先级。

   ```
   new AMQP.BasicProperties().builder().priority(i).build();
   ```

   