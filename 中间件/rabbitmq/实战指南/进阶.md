





# 备份交换器【Alternate Exchange】

## 使用场景

1. 当 `mandatory` 为false时，不会将未匹配到的消息返回给生产者，此时可使用备份交换器。
2. 当使用备份交换器时，`mandatory` 参数不生效。

## 使用方式

1. ```java
   args.put("alternate-exchange", "备份交换器名称");
   // 声明主交换器时将参数传入
   ```

2. ```sh
   rabbitmqctl set_policy AE "^主交换器名称$" `{"alternate-exchange": "备份交换器名称"}`
   ```

## 注意事项

1. 备份交换器最好设置为**fanout**类型。
2. 消息被发送到备份交换器时的路由键和从生产者发出的路由键是一样的。

## 特殊情况

1. **备份交换器不存在**，客户端、服务端不会出现异常，消息丢失。
2. **备份交换器没有绑定任何队列**，客户端、服务端不会出现异常，消息丢失。
3. **备份交换器没有任何匹配的队列**，客户端、服务端不会出现异常，消息丢失。
4. 备份交换器和 `mandatory` **一起使用**， `mandatory` 参数无效。

# 过期时间【TTL】

## 消息

### 队列中设置

1. 声明队列时设置。

   ```java
   args.put("x-message-ttl",6000);
   ```

2. 命令行设置。

   ```sh
   rabbitmqctl set_policy TTL ".*" '{"message-ttl": 60000}' --apply-to queueName
   ```

3. API设置。

   ```shell
   curl -i -u root:root -H "content-type:application/json" -X PUT -d '{"auto_delete":flase, "durable": true, "argument": {"x-message-ttl",6000}}' http://localhost:15672/api/queues/{vhost}/{queueName}
   ```

4. 消息过期时会立马从队列中删除。

5. 若果ttl为0，表示需要被立即消费，否则被丢弃，可配合死信队列使用。

### 消息中设置

1. 发送消息时设置。

   ```java
   new AMQP.BasicProperties().builder().expiration("6000").build(),
   ```

2. API设置。

   ```shell
   curl -i -u root:root -H "content-type:application/json" -X PUT -d '{"properties": {"expiration": "60000"}, "routing_key": "keyName"}' http://localhost:15672/api/exchanges/{vhost}/{exchangesname}/publish
   ```

3. 不会立马从队列中删除，在即将投递给消费者之前判断。

## 队列

声明队列时设置。

```java
args.put("x-expires", 18000);
```

含义为：在过期时间内没有被使用过的队列就删除。

# 死信队列【Dead-Letter-Exchange】

当消息在一个队列中变成死信之后，能被重新发送到另一个交换器，这个交换器就是`DLX`。绑定`DLX`的队列就称为死信队列。

## 消息死信队列的情况

1. 消息被拒绝，并且 requeue参数为false。
2. 消息过期。
3. 队列达到最大长度。

将死信队列和正常队列的ttl设置为0，可以替代`immediate`参数的功能。

## 设置方式

1. 声明队列时设置。

   ```java
   args.put("x-dead-letter-exchange", exchangeName);
   ```

2. 命令行设置。

   ```sh
   rabbitmqctl set_policy DLX ".*" '{"dead-letter-exchange": "死信交换器名称"}' --apply-to queues
   ```

3. 发到死信交换器的routing-key沿用正常队列的，也可手动指定。

   ```java
   args.put("x-dead-letter-routing-key", Config.dxRoutingKey);
   ```

## 适用场景

1. 延时队列。
2. 通过分析消费死信队列中的消息来分析异常情况，改善系统状态。

# 延时队列

通过死信队列 + 过期时间可实现延时功能。

## 使用场景

1. 订单15分钟未支付过期。
2. 对消息指定时间处理。

# 优先级队列

1. 设置队列的最大优先级。

   ```java
   param.put("x-max-priority", maxPriority);
   ```

2. 投递消息时设置消息优先级。

   ```
   new AMQP.BasicProperties().builder().priority(i).build();
   ```

# RPC实现【Remote Procedure Call】

1. 用到两个属性：`relayTo` 和 `correlationId`。
2. 客户端启动时，创建回调队列。
3. 客户端为RPC请求设置两个属性：
   1. `relayTo` 用来告知RPC服务端回复请求时的目的队列，即回调队列。
   2. `correlationId` 用来标记一个请求。
4. 请求被发送到 `rpc` 队列。
5. 服务器监听 `rpc` 队列，当请求来到时，服务端处理请求，并将根据 `relayTo` 将结果发到回调队列，携带 `correlationId` 。
6. 客户端监听回调队列，当有消息时，检查 `correlationId` ，如果匹配，拿到结果。

![](imgs/rpc实现.png)

# 持久化

## 交换器

```
1. 声明交换器时设置 duration：true
2. 不持久化的影响：rabbitmq重启时，交换器元数据会丢失，消息不会丢失，且不能将消息再发送给这个交换器了。
```

## 队列

```
1. 声明队列时设置 duration：true
2. 不持久化的影响：rabbitmq重启时，队列的元数据会丢失，消息也会丢失。
```

## 消息

```
1. 发送消息时设置 delivery-mode：2
2. 不持久化的影响：rabbitmq重启时，消息会丢失。
3. 队列和消息都设置持久化才有意义。
```

## 交换器，队列，消息全部持久化，消息也有丢失的情况如下：

```
1. 消息者设置autoAck=true，在处理消息之前宕机。
2. 数据在操作系统缓存中，还未落盘时宕机。
```

# 生产者确认

保证生产者发出的消息能够到达mq。

## 事务机制

将信道设置为事务模式

```java
// 开启事务，将信道设置为事务模式
channel.txSelect();
try {
  channel.basicPublish(
    exchangeName,
    routingKey,
    MessageProperties.PERSISTENT_TEXT_PLAIN,
    "tx".getBytes(StandardCharsets.UTF_8));
  // 提交事务
  channel.txCommit();
} catch (Exception e) {
  e.printStackTrace();
  // 回滚事务
  channel.txRollback();
}
```

使用事务机制会"吸干" RabbitMQ 的性能，非最佳方法。

<img src="imgs/事务提交.png" alt="事务提交" style="zoom:30%;" /><img src="imgs/事务回滚.png" alt="事务回滚" style="zoom:40%;" />

## 发送方确认

1. 将信道设置为确认【confirm】模式，在该信道上发送的消息，都会指派一个唯一的消息ID。
2. 消息被投递给所有匹配的队列后，rabbitmq给生产者回复Basic.Ack或Basic.Nack。
3. <img src="imgs/发送方确认.png" alt="发送方确认" style="zoom:30%;" />

### 实现方式

实现方式有三种，详细见[代码](./exercises/src/main/java/com/confirm)。

1. 同步。
2. 批量同步。
3. 异步。

## 两种方式比较

1. 互斥。
2. 事务机制是同步的，确认机制可以异步。

# 消费端要点介绍

## 消息分发

1. 分发机制：轮询分发【n%m】:n-第几条消费者，m:消费者个数。
2. 缺陷：消费者处理消息的能力有差异，对于性能较差的消费者会出现消费积压，恶性循环。
3. 解决办法：对消费者设置Qos【消费者可以持有的未确认的消息数量】。

### Qos

```java
channel.basicQos(int prefetchSize, int prefetchCount, boolean gobal);
```

1. prefetchSize：消费者可以持有的未确认的消息总大小。
2. prefetchCount：消费者可以持有的未确认的消息数量。
3. gobal：在一个信道中有多个消费者时消费多个队列时使用。
   1. false：新的消费者可以持有的未确认的消息数量。
   2. true：信道中所有消费者总共可以持有的未确认的消息数量。

## 消息顺序性

消息顺序性是指：消费者消费到的消息和生产者发布的消息顺序一致。

### 保证方法

只有一个生产者，只有一个消费者，且消息不会丢失，没有网络故障。

### 打乱原因

1. 延迟队列。
2. 优先级队列。
3. 发送方确认机制，未确认后异步重发。
4. 消费者拒绝后重发。

## QueueingConsumer弃用原因

1. QueueingConsumer内部使用LinkedBlockingQueue来缓存消息，消费速度赶不上生产速度时，会产生内存堆积。
2. QueueingConsumer会拖累同一个链接下的所有信道，使其性能降低。
3. 同步递归调用QueueingConsumer会产生死锁。
4. mq的自动连接恢复机制不支持QueueingConsumer。
5. QueueingConsumer不是事件驱动的。

# 消息传输保障

消息中间件的传输保障分为三个层级：

1. `At most once`：最多一次。消息可能丢失，但绝不会重复传输。
2. `At least once`：最少一次。消息绝不会丢失，但可能会重复传输。
3. `Exactly once`：恰巧一次。每条消息肯定会被传输一次并且仅传输一次。

### 保障方式

第一层比较简单，生产者随意发，消费者随意消费。

第二层：

1. 生产者开启确认机制，确保消息发送到了mq服务器。
2. 生产者使用mandatory或者备份交换器保证消息能被路由到队列。
3. 消息和队列都持久化，保证服务器异常重启不会丢失消息。
4. 消费者消费是autoAck设置成false，手动确认消息已消费。

第三层mq本身没有机制保障，可以用幂等校验或者redis来去重。