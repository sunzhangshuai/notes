# 搭建

## 多机多节点

1. 配置各个节点的hosts文件，添加节点名称与ip地址的映射信息。

2. 编辑rabbitmq的cookie文件：

   1. 各个节点改成一样的值。
   2. 节点需要通过交换密钥令牌以获得相互认证，如果不一样join的时候会报错。
   3. 默认路径：`$HOME/.erlang.cookie`。

3. 配置集群：

   1. 有三种方式：**通过rabbitmqctl工具**，修改rabbitmq.config，通过Rabbitmq-autocluster插件配置。

   2. rabbitmqctl工具配置： 

      1. 启动各个节点

          ```shell
          rabbitmq-server -detached
          ```

      2. 以第一个节点为基准，把其他节点加入到第一个节点。

          ```shell
          rabbitmqctl stop_app
          rabbitmqctl reset
          rabbitmqctl join_cluster rabbitmq@node1
          rabbitmqctl start_app
          ```

4. 如果关闭了集群的所有节点，再启动集群时，需要先启动最后一个关闭的节点，如果第一个启动的不是最后一个关闭的节点，需要等待最后一个关闭的节点启动，这个等待时间是30s。

## 集群节点类型

1. 集群中的每一个节点都保存了所有的队列、交换器、绑定关系、用户、权限和vhost的元数据信息。
2. 集群中的节点分为两类：内存节点【ram】和磁盘节点【disc】。

### 磁盘节点【disc】

1. 单节点的集群中只有磁盘节点；多节点的集群至少有一个磁盘节点。
2. 集群中所有磁盘节点都崩溃时，集群可以继续发送和接收消息，但不能执行创建队列、交换器等修改元数据的操作。
3. 在集群中添加内存节点，要告知所有的磁盘节点。内存节点至少找到一个磁盘节点，就可以加入集群。
4. 为了保证集群信息的可靠性，建议全部使用磁盘节点。

### 内存节点【ram】

1. 加入集群时指定为内存节点

   ```shell
   rabbitmqctl join_cluster rabbit@node1 --ram
   ```

2. 修改集群节点类型

   ```shell
   rabbitmqctl stop_app
   rabbitmqctl change_cluster_node_type {disc|ram}
   rabbitmqctl start_app
   ```

3. 在集群中创建队列，交换器或者绑定关系的时候，这些操作直到所有集群节点都成功提交元数据变更才返回，故内存节点可以提供出色的性能。

4. 内存节点重启后，会连接到预先配置的磁盘节点，下载集群元数据的副本。

5. 在集群中创建队列，交换器或者绑定关系的时候，这些操作直到所有集群节点都成功提交元数据变更才返回，故内存节点可以提供出色的性能。

6. 内存节点重启后，会连接到预先配置的磁盘节点，下载集群元数据的副本。

## 剔除单个节点

以node1、node2、node3集群为例，剔除node2

### 方法一

1. 在node2上执行

   ````shell
   rabbitmqctl stop_app
   ````

2. 在node1或者node3上执行

   ```shell
   rabbitmqctl forget_cluster_node rabbit@node2 [-offline]
   ```

   1. 不加offline：需要节点在运行状态下。
   2. 加offline：节点可以在离线状态下。比如集群关闭顺序为：node3、node2、node1。可以在节点node2上执行forget_cluster_node来剔除node1。

### 方法二

在node2上执行

```
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app
```

## 集群节点的升级

### 单节点集群升级

1. 关闭原来的服务
2. 新节点的mnesia路径指向与原节点相同。
3. 解压新版本运行

### 多节点集群升级

1. 关闭所有的节点的服务，注意采用rabbitmqctl stop命令关闭。
2. 保存各个节点的mnesia数据。
3. 解压新版本的rabbitmq到指定的目录。
4. 指定新版本的mnesia路径为步骤2中保存的mnesia数据路径。
5. 启动新版本的服务，注意先启动原版本中最后关闭的节点。

## 单机多节点

```shell
# 启动
RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit1 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15672}]" rabbitmq-server -detached
RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit2 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15673}]" rabbitmq-server -detached
RABBITMQ_NODE_PORT=5674 RABBITMQ_NODENAME=rabbit3 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15674}]" rabbitmq-server -detached

# 加入集群
rabbitmqctl -n rabbit2@zhangshuai24deMacBook-Pro stop_app
rabbitmqctl -n rabbit2@zhangshuai24deMacBook-Pro reset
rabbitmqctl -n rabbit2@zhangshuai24deMacBook-Pro join_cluster rabbit1@zhangshuai24deMacBook-Pro
rabbitmqctl -n rabbit2@zhangshuai24deMacBook-Pro start_app
rabbitmqctl -n rabbit3@zhangshuai24deMacBook-Pro stop_app
rabbitmqctl -n rabbit3@zhangshuai24deMacBook-Pro reset
rabbitmqctl -n rabbit3@zhangshuai24deMacBook-Pro join_cluster rabbit1@zhangshuai24deMacBook-Pro
rabbitmqctl -n rabbit3@zhangshuai24deMacBook-Pro start_app
```

# 集群迁移

## 元数据重建

指在新的集群中创建原集群的队列、交换器、绑定关系、vhost、用户、权限和Parameter等数据信息。

### 高效率重建

1. 从web管理页面上下载旧的原数据json。
2. 将json在新的集群web管理页面进行上传。

#### 需要考虑三个问题

1. 旧的开启management插件的节点故障不可修复，无法获取元数据 `metadata.json`。

   采取一个通用的备份任务，在元数据有变更或者达到某个存储周期时将最新的 `metadata.json` 备份至另一处安全的地方。

2. Mq版本不一致，上传失败。

   1. 密码加密方式不同：可通过命令修改密码解决。
   2. 其他问题：
      1. 手工在新集群中建立出队列、交换器、绑定关系的其他元数据（用户、策略、权限）。
      2. 从新创建好的集群中下载文件，复制queues之前的配置到旧的配置文件中，将旧的配置文件上传的新创建的集群中。

3. 将元数据在新集群上重建，则所有的队列都只会落到同一个集群节点上，而其他节点处于空置状态。

   通过代码解析json，将队列分散创建在不同节点上。

   1. [以channel方式迁移](exercises/src/main/java/com/cluster/metaTransfer/TransferWithChannel.java)
   2. [以http接口方式迁移](exercises/src/main/java/com/cluster/metaTransfer/TransferWithHttp.java)

   个人分析：只需分散建立队列即可，交换器、绑定关系只属于元数据。

## 数据迁移

使用Federation 或者 Shove 插件先从原集群把未消息的消息消费出来，再发送给新集群。

## 客户端连接切换

生产者客户端直接与原集群断开，连接新集群。

消费者客户端可以先消费完原集群的消息，再切换到新集群；如果原集群故障，可以先切到新集群，等原集群恢复后，使用Federation 或者 Shove 插件先从原集群把未消息的消息消费出来，再发送给新集群。

## 自动化迁移

将集群分为三部分：客户端，zookeeper，集群。

<img src="imgs/自动化迁移.jpg" alt="自动化迁移" style="zoom:50%;" />

生产者发消息时：

1. 先连接zookeeper。
2. 根据路径 `rmqNode/exchanges/exchangeName`  读取该节点的数据，并对此节点添加 watcher。
3. 从数据中找到交换器所在集群名称`cluster = clusterName` ，根据路径`rmqNode/clusters/clusterName` 读取集群节点的数据。拿到ipList。
4. lP 地址列表、 vhost、 userName、password 等都已获取。
5. 客户端与集群建立连接。

消费者接收消息时：

1. 先连接zookeeper。
2. 根据路径 `rmqNode/exchanges/queueName`  读取该节点的数据，并对此节点添加 watcher。
3. 从数据中找到交换器所在集群名称`cluster = clusterName` ，根据路径`rmqNode/clusters/clusterName` 读取集群节点的数据。拿到ipList。
4. lP 地址列表、 vhost、 userName、password 等都已获取，客户端与集群建立连接。

集群切换时：

1. 在新的 cluster 上重建旧的 cluster 上的元数据。

2. 先变更交换器相关的 ZooKeeper 中的节点数据。【**切换生产者**】

3. 待原集群中的所有队列都消费完全之后，再将队列相关的 ZooKeeper 中的节点数据变更。【**切换消费者**】

4. 查看是否有队列中的消息未被消费完：

   ```shell
   rabbitmqctl list queues -p / -q I awk '{if($2>0) print $0}'
   ```

上面的自动化迁移立足于将现有集群迁移到空闲的备份集群。

### 循环备份

<img src="imgs/循环备份.jpg" alt="循环备份" style="zoom:50%;" />

### 以一备二

<img src="imgs/以一备二.jpg" alt="以一备二" style="zoom:50%;" />

