# 队列

## 概念

1. 消息都只能存储在队列中，kafka是存储在主题逻辑层面。
2. 多个消费者可以订阅同一队列，队列中的消息会被平均分摊。
3. 不支持队列层面的广播。
4. 订阅排他：消费者在同一信道订阅其他队列后，不可再声明队列。
5. 建议通过后台管理系统预先创建资源。
6. 如果消息投递的目的队列是空的，并且有消费者订阅了这个队列。消息会直接投递给消费者，不进队列。
7. 队列具备两种模式: **default** 和 **lazy** 。

### 过期时间

1. 声明队列时设置。

```java
args.put("x-expires", 18000);
```

2. 含义为：在过期时间内没有被使用过的队列就删除。

## 结构

<img src="imgs/队列.png" alt="队列" style="zoom:50%;" />

### 消息在队列中的状态

|        状态         | 消息内容存储位置 | 消息索引存储位置 |
| :-----------------: | :--------------: | :--------------: |
|        alpha        |       内存       |       内存       |
|        beta         |       磁盘       |       内存       |
| gamma【持久化独有】 |       磁盘       |    磁盘、内存    |
|        delta        |       磁盘       |       磁盘       |

### rabbit_amqqueue_process

#### 作用

负责协议相关的消息处理

1. 接收生产者发布的消息；
2. 向消费者交付消息；
3. 处理消息的确认【生产端的confirm、消费端的ack】。

### backing_queue

#### 作用

1. 消息存储的具体形式和引擎。
2. 向 rabbit_amqqueue_process 提供相关的接口以供调用。

#### rabbit_variable_queue

backing_queue的默认实现，内部有5个子队列：Q1、Q2、delta、Q3、Q4。

1. Q1、Q4只包含alpha状态的消息。
2. Q2、Q3只包含beta和gamma状态的消息。
3. delta只包含delta状态的消息。

##### 消息入队

1. 消息流动方向：Q1 -> Q2 -> delta -> Q3 -> Q4。
2. 负载正常时：消息被消费的速度不小于接收新消息的速度。
   1. 非持久化消息：极有可能只会处于 alpha 状态。
   2. 持久化消息：必会进入 gamma 状态，在开启 publisher confirm 机制时，只有到了 gamma 状态时才会确认该消息己被接收。
3. 负载较高时
   1. 表现：消息会进到较深的队列中去，增加处理每个消息的平均开销。
   2. 措施
      1. 增加 refetch count 的值，即一次发送多条消息给消费者，加快消息被消费的速度。
      2. 采用 multipl ack ，降低处理 ack 带来的开销。
      3. 流量控制。

##### 获取消息

1. 从Q4中获取消息，如果获取成功直接返回。没有进入下一步。
2. 从Q3中获取消息，
   1. 如果Q3中有，拿出Q3中的消息，然后判断Q3和delta中的消息条数。
      1. Q3、delta都为空：则Q4、Q3、delta、Q2中都没有消息，将Q1中消息直接转移至Q4。
      2. Q3为空、delta不为空：将delta的消息分段转移至Q3。判断转移的条数是否和delta中条数相同。
         1. 相同：detal中没有消息，同时将Q2中的消息直接转移到Q3。
         2. 不同：结束。
   2. 如果Q3中没有消息，返回队列为空，此时队列中无消息。

## 基本操作

### 创建

#### 定义

```java
Queue.DeclareOk queueDeclare(
  String queue, 
  boolean durable, 
  boolean exclusive, 
  boolean autoDelete,
  Map<String, Object> arguments
) throws IOException;
```

#### 参数

1. queue：队列名称。
2. durable：是否持久化。
   1. true为持久化，将队列存盘。
   2. 不持久化的影响：rabbitmq重启时，队列的元数据会丢失，消息也会丢失。
3. exclusive：是否排他，true为排他，仅对首次声明他的队列连接可见。
   1. 基于连接。
   2. 同一连接的不同信道可同时访问同一连接创建的排他队列。
   3. 排他队列全局不可重名。
   4. <span style="color:red">连接关闭或客户端退出时删除</span>，**即使持久化**。
4. autoDelete：自动删除。所有与这个队列连接的消费者都断开时，删除队列。【**一次性**】
   1. 前提：必须有一个消费者连接过。
   2. 所有消费者都断开时，自动删除。
5. arguments：结构化参数。
   1. 死信交换器：x-dead-letter-exchange
   2. 死信路由键：x-dead-letter-routing-key
   3. 队列最大长度：x-max-length
   4. 惰性队列：x-queue-mode：layz
   5. 镜像队列的复制方式：x-ha-policy：all、nodes、exactly【指定个数】

### 声明已有队列

```java
Queue.DeclareOk queueDeclarePassive(String queue) throws IOException;
```

1. 队列不存在时抛出 404 异常。

### 删除

```java
Queue.DeleteOk queueDelete(String queue, boolean ifUnused, boolean ifEmpty) throws IOException;
```

## 应用

### 死信队列

当消息在一个队列中变成死信之后，能被重新发送到另一个交换器，这个交换器就是Dead-Letter-Exchange【DLX】。绑定`DLX`的队列就称为死信队列。

#### 消息进入死信队列的情况

1. 消息被拒绝，并且 requeue参数为false。

2. 消息过期。

3. 队列达到最大长度。

   1. 设置队列最大长度

      ```shell
      args.put("x-max-length", 100);
      ```

   2. 如果队列达到最大长度，从队头进入死信队列。

将死信队列和正常队列的ttl设置为0，可以替代`immediate`参数的功能。

#### 使用方式

```java
// 1. 声明队列时设置。
args.put("x-dead-letter-exchange", exchangeName);
// 2. 命令行设置。
rabbitmqctl set_policy DLX ".*" '{"dead-letter-exchange": "死信交换器名称"}' --apply-to queues
```

#### 适用场景

1. 延时队列。
2. 通过分析消费死信队列中的消息来分析异常情况，改善系统状态。

#### [参考代码](exercises/src/main/java/com/dxq)

### 延时队列

通过死信队列 + 过期时间可实现延时功能。

#### 适用场景

1. 订单15分钟未支付过期。
2. 对消息指定时间处理。

#### [参考代码](exercises/src/main/java/com/delay)

### 优先级队列

#### 使用方式

```java
// 1. 设置队列的最大优先级。
param.put("x-max-priority", maxPriority);
// 2. 投递消息时设置消息优先级。
new AMQP.BasicProperties().builder().priority(i).build();
```

#### [参考代码](exercises/src/main/java/com/priority)

### 惰性队列

#### 使用方式

```java
// 1. 声明队列时设置。
args.put("x-queue-mode", "lazy");
// 2. 命令行设置。
rabbitmqctl set_policy policyName "正则表达式" '{"queue-mode": "lazy"}' --apply-to queues
```

#### 存储机制

1. 惰性队列会将消息直接存入文件系统，无论是否持久化。在消费者消费到相应的消息时才会被加载到内存中。
2. 如果要发送1千万条消息，普通队列发送速度约为 13000 条/秒。
3. 如果要发送1千万条消息，惰性队列发送速度约为 24000 条/秒。

## 管理

```shell
rabbitmqctl list_queues [-p vhost] [queueInfoItem...]
```

queueInfoItem用于指示哪些队列的信息项会展示在结果集中。如果没有指定 queueinfoitems ，那么此命令将显示**队列的名称**和**消息的个数**。

1. name：队列名称。
2. durable：队列是否持久化。
3. auto_delete：队列是否自动删除。
4. arguments：队列的参数。
5. policy：队列上应用的策略名称。
6. pid：队列关联的`Erlang`进程的id。
7. owner_pid：处理排他队列的`Erlang`进程的id，如果此队列是非排他的，此值为空。
8. exclusive：队列是否是排他的。
9. exclusive_consumer_pid：订阅到此排他队列的消费者相关的信道关联的`Erlang`进程 。如果此队列是非排他的，此值将为空。
10. exclusive_consumer_tag：订阅到此排他队列的消费者的 consumerTag 如果此队列是非排他的，此值将为空。
11. messages_ready：准备发送给客户端的消息个数。
12. messages_unacknowledged：发送给客户端但尚未应答的消息个数。
13. messages：准备发送给客户端和未应答消息的总和。
14. messages_ready_ram：驻留在内存中 messages_ready 的消息个数。
15. messages_unacknowledged_ram：驻留在内存中 messages_unacknowledged 的消息个数。
16. messages_ram：驻留在内存中的消息总数。
17. messages_persistent：队列中持久化消息的个数，对于非持久化队列来说总是0。
18. messages_bytes：队列中所有消息的大小总和，这里不包括消息属性或者任何其他开销。
19. messages_bytes_ready：准备发送给客户端的消息的大小总和。
20. messages_bytes_unacknowledged：发送给客户端但尚未应答的消息的大小总和。
21. messages_bytes_ram：驻留在内存中的消息的大小总和。
22. messages_bytes_persistent：队列中持久化的 messages_bytes。
23. disk_reads：从队列启动开始，已从磁盘中读取该队列的消息总次数。
24. disk_writes：从队列启动开始，已向磁盘队列写消息的总次数。
25. consumer：消费者数目。
26. consumer_utilisation：队列中的消息能够立刻投递给消费者的比率。介于0~1之间 。这个受网络拥塞或者 `Basic.Qos` 的影响而小于1。
27. memory：与队列相关的 `Erlang` 进程所消耗的内存字节数，包括栈、堆及内部结构。
28. slave_pids：如果队列是镜像的，列出所有 slave 镜像的 pid。
29. synchronised_slave_pids：如果队列是镜像的，列出所有已经同步的 slave 镜像的pid。
30. state：队列状态。正常情况下是 running。如果队列正常同步数据可能会有 syncing、MsgCount 的状态。

## 配置

文件配置：rabbitmq.conf

|                     变量名                     | 含义                                                         |
| :--------------------------------------------: | ------------------------------------------------------------ |
|          queue_index_embed_msg_below           | 消息的大小，小于此值时会直接嵌入到队列的索引中。单位为B，默认值为4096。 |
|              backing_queue_module              | 队列内容的实现模块。默认为rabbit_variable_queue。不建议修改此项。 |
|              queue_master_locator              | 队列的定位策略。                                             |
| lazy_queue_explicit_gc_run_operation_threshold | 在使用惰性队列（lazy queue）时进行内存回收动作的阀值。默认值为1000。 |
|   queue_explicit_gc_run_operation_threshold    | 在使用正常队列时进行内存回收动作的阀值。默认值为1000。       |