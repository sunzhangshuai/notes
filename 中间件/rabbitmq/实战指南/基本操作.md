# 连接

1. `Connection`可以用来创建多个`Channel`实例。
2. `Channel`实例不能线程间共享，每个线程应该创建一个`Channel`实例。

# 交换器

建议预先创建资源，通过后台管理系统。

## 声明交换器

```java
Exchange.DeclareOk exchangeDeclare(
 	String exchange,
  BuiltinExchangeType type,
  boolean durable,
  boolean autoDelete,
  boolean internal,
  Map<String, Object> arguments
) throws IOException;
```

1. exchange：交换器名称。
2. type：交换器类型，fanout、direct、topic等。
3. durable：是否持久化。true为持久化，将交换器存盘。
4. autoDelete：自动删除。true为当所有绑定队列都不在使用时，自动删除交换器。【**一次性**】
   1. 前提：必须有交换机或队列绑定过。
   2. 所有绑定都断开时，自动删除。
5. internal：是否设置成内置的。true为必须通过交换器路由到此交换器。
6. arguments：结构化参数。

## 绑定交换器

```java
Exchange.BindOk exchangeBind(
  String destination, 
  String source, 
  String routingKey, 
  Map<String, Object> arguments
) throws IOException;
```

1. destination：目标交换器。
   1. 一般目标交换器类型为：fanout。
2. source：源交换器。

## 解绑交换器

```java
Exchange.UnbindOk exchangeUnbind(
  String destination, 
  String source, 
  String routingKey, 
  Map<String, Object> arguments
) throws IOException;
```

# 队列

建议预先创建资源，通过后台管理系统。

## 声明队列

```java
Queue.DeclareOk queueDeclare(
  String queue, 
  boolean durable, 
  boolean exclusive, 
  boolean autoDelete,
  Map<String, Object> arguments
) throws IOException;
```

1. queue：队列名称。
2. durable：是否持久化。true为持久化，将队列存盘。
3. exclusive：是否排他，true为排他，仅对首次声明他的队列连接可见。
   1. 基于连接。
   2. 同一连接的不同信道可同时访问同一连接创建的排他队列。
   3. 排他队列全局不可重名。
   4. <span style="color:red">连接关闭或客户端退出时删除</span>，**即使持久化**。
4. autoDelete：自动删除。所有与这个队列连接的消费者都断开时，删除队列。【**一次性**】
   1. 前提：必须有一个消费者连接过。
   2. 所有消费者都断开时，自动删除。
5. arguments：结构化参数。

## 声明已有队列

```java
Queue.DeclareOk queueDeclarePassive(String queue) throws IOException;
```

1. 队列不存在时抛出 404 异常。

## 删除队列

```java
Queue.DeleteOk queueDelete(String queue, boolean ifUnused, boolean ifEmpty) throws IOException;
```

### 不建议使用

```java
void queueDeleteNoWait(String queue, boolean ifUnused, boolean ifEmpty) throws IOException;
```

无返回值。

## 绑定队列

```java
Queue.BindOk queueBind(
  String queue, 
  String exchange, 
  String routingKey, 
  Map<String, Object> arguments
) throws IOException;
```

1. queue：队列名称。
2. exchange：交换器名称。
3. routingKey：绑定队列和交换器的路由键。
4. arguments：绑定时的额外参数。

## 解绑队列

```java
Queue.UnbindOk queueUnbind(
  String queue,
  String exchange, 
  String routingKey, 
  Map<String, Object> arguments
) throws IOException;
```

## 注意

1. 消费者在同一信道订阅其他队列后，不可再声明队列。【订阅排他】。

# 发送消息

```java
void basicPublish(
  String exchange, 
  String routingKey, 
  boolean mandatory, 
  boolean immediate, 
  BasicProperties props, 
  byte[] body
) throws IOException;
```

1. exchange：交换器名称。

2. routingKey：指定的路由键。为空

3. mandatory：

   1. `true`：当交换器找不到符合条件的对列，rabbitMQ调用`Basic.Return` 将消息退回给生产者。获取方式如下：

      ```java
      channel.addReturnListener(
        new ReturnListener() {
          @Override
          public void handleReturn(
            int replyCode,
            String replyText,
            String exchange,
            String routingKey,
            AMQP.BasicProperties properties,
            byte[] body) throws IOException {
            System.out.println("Basic.return 返回的消息是:" + new String(body));
          }
      });
      ```

      1. 新增监听器。`channel.addReturnListener`。
      2. 监听器中实现 `handleReturn` 方法。

   2. `false`：当交换器找不到符合条件的对列，直接丢弃消息。

4. immediate：

   1. `true`：交换器将消息路由到队列时，发现队列上不存在消费者，将不会入队，如果所有队列都没消费者，rabbitMQ调用`Basic.Return` 将消息退回给生产者。
   2. `false`：默认。
   3. 3.0去掉了，影响镜像队列性能，增加了代码复杂性。

5. props：消息的基本属性集。

   1. content-type：让消费者知道如何解释消息体。
   2. content-encoding：指示消息体使用某种特殊的方式进行压缩或编码。
   3. message-id属性：唯一消息标识。可以用于去重。
   4. correlation-id属性：消息响应标识。可以用于拓扑排序。
   5. timestamp属性：表示消息创建时间。
   6. expiration属性：表示消息的过期时间。
      1. UNIX纪元时间或整数时间戳，然后把它存储为字符串。精度是毫秒。
      2. 已经超时的消息发布到服务器，不会被路由到任何队列，而是被直接丢弃。
   7. delivery-mode属性：将消息写入磁盘或内存队列。
      1. `1`：非持久化消息。
      2. `2`：持久化消息。
   8. app-id和user-id属性：帮助追踪出现问题的消息发布者应用程序。
   9. type属性：表示发布者和消费者之间的契约。
      1. 一般可以用于描述消息中的内容，应用程序可以根据它来确定如何处理一个消息。
   10. reply-to属性：实现响应消息的路由。
   11. headers属性：定义自由格式的属性和实现RabbitMQ路由。
       1. key可以是ASCII或Unicode字符串，最大长度为255个字符。
       2. value可以是任何有效的AMQP值类型。
   12. priority属性：值被定义为0~9之间。用于指定队列中消息的优先级。**不建议使用**。

6. body：消息体，真正要发送的消息。

# 消费消息

## 推模式【推荐】

```java
String basicConsume(
  String queue, 
  boolean autoAck, 
  String consumerTag, 
  boolean noLocal, 
  boolean exclusive, 
  Map<String, Object> arguments, 
  Consumer callback
) throws IOException;
```

1. queue：队列名称。

2. autoAck：设置是否自动确认，建议设置为false。

3. consumerTag：消费者标签，用来区分多个消费者。

4. noLocal：消费者不消费同一连接中生产者发送的消息。

5. exclusive：设置是否排他。

   1. true：只有1个消费者来消费消息。

6. arguments：

7. callback：设置消费者的回调函数。

   1. ```java
      void handleDelivery(
        String consumerTag,
        Envelope envelope,
        AMQP.BasicProperties properties,
        byte[] body
      )throws IOException;
      ```

      1. envelope：环境变量。
      2. 队列向消费者推消息`basic.deliver`时调用。

   2. ```java
      void handleConsumeOk(String consumerTag);
      ```

      1. 开始消费`Channel.basicConsume`时调用。

   3. ```java
      void handleCancel(String consumerTag) throws IOException;
      ```

      1. 取消订阅时调用。

   4. ```java
      void handleCancelOk(String consumerTag);
      ```

      1. 取消订阅时调用。

   5. ```java
      void handleShutdownSignal(String consumerTag, ShutdownSignalException sig);
      ```

      1. channel或connection关闭时调用。

   6. ```java
      void handleRecoverOk(String consumerTag);
      ```

      1. 重新发送未被确认的消息时调用。

## 拉模式

```java
GetResponse basicGet(String queue, boolean autoAck) throws IOException;
```

1. queue：队列名称。
2. autoAck：是否自动确认。

## 确认与拒绝

### 确认

```java
void basicAck(long deliveryTag, boolean multiple) throws IOException;
```

1. deliveryTag：消息编号。
2. multiple：
   1. true：只确认当前的消息。
   2. false：确认当前以及之前的所有未确认的消息。

消费者订阅时，设置autoAck：

1. true：发出去的消息自动确认，然后从内存（磁盘）中删除，不关心消费者是否消费成功。

2. false:  

   1. 消费者显式的调用Basic.Ack时，才会把消息删除。
   2. 队列中的消息分为2个部分：
      1. ready：等待被消费的消息。
      2. unacknowledge：等待被确认的消息。
      3. 待被确认的消息不会有过期时间，当消费者与队列断开连接时【**唯一条件**】，消息重新入队。

3. 查看队列消费状态

   ```shell
   rabbitmqctl list_queues name message_ready messages_acknowledged
   ```

### 拒绝

```java
void basicReject(long deliveryTag, boolean requeue) throws IOException;
```

1. deliveryTag：消息编号。
2. requeue：
   1. true：重新入队。
   2. false：直接移除。
3. 一次只能拒绝一条消息。

```java
void basicNack(
  long deliveryTag, 
  boolean multiple, 
  boolean requeue) throws IOException;
```

1. multiple：
   1. false：只拒绝当前消息。
   2. true：拒绝deliveryTag编号之前未被该消费者确认的消息。

```java
Basic.RecoverOk basicRecover(boolean requeue) throws IOException;
```

1. requeue 默认true。
   1. true：重新加入列表，再分配时，可能被分配给与之前不同的消费者。
   2. false：重新加入列表，再分配时，可能被分配给与之前相同的消费者。

