# 消息

## 概念

在消息路由的过程中，消息的标签会丢弃掉。队列中只有消息体。

## 组成

### 消息体

payload，带有业务逻辑的数据。

### 标签

label，表述消息，交换器、路由键。

## 过期策略

### 过期时间

#### 队列中设置

```shell
// 1. 声明队列时设置。
args.put("x-message-ttl",6000);
// 2. 命令行设置。
rabbitmqctl set_policy TTL ".*" '{"message-ttl": 60000}' --apply-to queueName
// 3. 通过API接口设置。
curl -i -u root:root -H "content-type:application/json" -X PUT -d '{"auto_delete":flase, "durable": true, "argument": {"x-message-ttl",6000}}' http://localhost:15672/api/queues/{vhost}/{queueName}
```

#### 发消息时设置

```shell
// 1. 发送消息时设置。
new AMQP.BasicProperties().builder().expiration("6000").build()
// 2. 通过API接口设置。
curl -i -u root:root -H "content-type:application/json" -X PUT -d '{"properties": {"expiration": "60000"}, "routing_key": "keyName"}' http://localhost:15672/api/exchanges/{vhost}/{exchangesname}/publish
```

### 过期删除策略

#### 队列中设置

1. 消息过期时会立马从队列中删除。
2. 若果ttl为0，表示需要被立即消费，否则被丢弃，可配合死信队列使用。

#### 发消息时设置

不会立马从队列中删除，在即将投递给消费者之前判断。

## 消息顺序性

消息顺序性是指：消费者消费到的消息和生产者发布的消息顺序一致。

### 保证方法

只有一个生产者，只有一个消费者，且消息不会丢失，没有网络故障。

### 打乱原因

1. 延迟队列。
2. 优先级队列。
3. 发送方确认机制，未确认后异步重发。
4. 消费者拒绝后重发。

### QueueingConsumer弃用原因

1. QueueingConsumer内部使用LinkedBlockingQueue来缓存消息，消费速度赶不上生产速度时，会产生内存堆积。
2. QueueingConsumer会拖累同一个链接下的所有信道，使其性能降低。
3. 同步递归调用QueueingConsumer会产生死锁。
4. mq的自动连接恢复机制不支持QueueingConsumer。
5. QueueingConsumer不是事件驱动的。

## 传输保障

消息中间件的传输保障分为三个层级：

1. `At most once`：最多一次。消息可能丢失，但绝不会重复传输。
2. `At least once`：最少一次。消息绝不会丢失，但可能会重复传输。
3. `Exactly once`：恰巧一次。每条消息肯定会被传输一次并且仅传输一次。

### 保障方式

第一层比较简单，生产者随意发，消费者随意消费。

第二层：

1. 生产者开启确认机制，确保消息发送到了mq服务器。
2. 生产者使用mandatory或者备份交换器保证消息能被路由到队列。
3. 消息和队列都持久化，保证服务器异常重启不会丢失消息。
4. 消费者消费是autoAck设置成false，手动确认消息已消费。

第三层mq本身没有机制保障，可以用幂等校验或者redis来去重。

## 持久化

交换器，队列，消息全部持久化，消息也有丢失的情况

1. 消息者设置autoAck=true，在处理消息之前宕机。
2. 数据在操作系统缓存中，还未落盘时宕机。

## 基本操作

```java
new AMQP.BasicProperties().builder().expiration("6000").timestamp().build()
```

### 消息属性

1. content-type：让消费者知道如何解释消息体。

2. content-encoding：指示消息体使用某种特殊的方式进行压缩或编码。

3. message-id：唯一消息标识。可以用于去重。

4. correlation-id：消息响应标识。可以用于拓扑排序。

5. timestamp：表示消息创建时间。

6. expiration：表示消息的过期时间。
   1. UNIX纪元时间或整数时间戳，然后把它存储为字符串。精度是毫秒。
   2. 已经超时的消息发布到服务器，不会被路由到任何队列，而是被直接丢弃。

7. delivery-mode：

   1. 将消息写入磁盘或内存队列。`1`：非持久化消息。`2`：持久化消息。
   2. 不持久化的影响：rabbitmq重启时，消息会丢失。队列和消息都设置持久化才有意义。

8. app-id和user-id：帮助追踪出现问题的消息发布者应用程序。

9. type：

   1. 表示发布者和消费者之间的契约。
   2. 一般可以用于描述消息中的内容，应用程序可以根据它来确定如何处理一个消息。

10. reply-to：实现响应消息的路由。

11. headers：定义自由格式的属性和实现RabbitMQ路由。

    1. key可以是ASCII或Unicode字符串，最大长度为255个字符。
    2. value可以是任何有效的AMQP值类型。

12. priority：消息优先级

    值被定义为0~9之间。用于指定队列中消息的优先级。**不建议使用**。

## 应用

### RPC实现【Remote Procedure Call】

#### 过程

1. 用到两个属性：`relayTo` 和 `correlationId`。
2. 客户端启动时，创建回调队列。
3. 客户端为RPC请求设置两个属性：
   1. `relayTo` 用来告知RPC服务端回复请求时的目的队列，即回调队列。
   2. `correlationId` 用来标记一个请求。
4. 请求被发送到 `rpc` 队列。
5. 服务器监听 `rpc` 队列，当请求来到时，服务端处理请求，并将根据 `relayTo` 将结果发到回调队列，携带 `correlationId` 。
6. 客户端监听回调队列，当有消息时，检查 `correlationId` ，如果匹配，拿到结果。

![](/Users/sunchen/Documents/notes/中间件/rabbitmq/实战指南/imgs/rpc实现.png)

#### [参考代码](exercises/src/main/java/com/rpc)
