# 消息

## 概念

在消息路由的过程中，消息的标签会丢弃掉。队列中只有消息体。

## 组成

### 消息体

payload，带有业务逻辑的数据。

### 标签

label，表述消息，交换器、路由键。

## 过期策略

### 过期时间

#### 队列中设置

```shell
// 1. 声明队列时设置。
args.put("x-message-ttl",6000);
// 2. 命令行设置。
rabbitmqctl set_policy TTL ".*" '{"message-ttl": 60000}' --apply-to queueName
// 3. 通过API接口设置。
curl -i -u root:root -H "content-type:application/json" -X PUT -d '{"auto_delete":flase, "durable": true, "argument": {"x-message-ttl",6000}}' http://localhost:15672/api/queues/{vhost}/{queueName}
```

#### 发消息时设置

```shell
// 1. 发送消息时设置。
new AMQP.BasicProperties().builder().expiration("6000").build()
// 2. 通过API接口设置。
curl -i -u root:root -H "content-type:application/json" -X PUT -d '{"properties": {"expiration": "60000"}, "routing_key": "keyName"}' http://localhost:15672/api/exchanges/{vhost}/{exchangesname}/publish
```

### 过期删除策略

#### 队列中设置

1. 消息过期时会立马从队列中删除。
2. 若果ttl为0，表示需要被立即消费，否则被丢弃，可配合死信队列使用。

#### 发消息时设置

不会立马从队列中删除，在即将投递给消费者之前判断。

## 消息顺序性

消息顺序性是指：消费者消费到的消息和生产者发布的消息顺序一致。

### 保证方法

只有一个生产者，只有一个消费者，且消息不会丢失，没有网络故障。

### 打乱原因

1. 延迟队列。
2. 优先级队列。
3. 发送方确认机制，未确认后异步重发。
4. 消费者拒绝后重发。

### QueueingConsumer弃用原因

1. QueueingConsumer内部使用LinkedBlockingQueue来缓存消息，消费速度赶不上生产速度时，会产生内存堆积。
2. QueueingConsumer会拖累同一个链接下的所有信道，使其性能降低。
3. 同步递归调用QueueingConsumer会产生死锁。
4. mq的自动连接恢复机制不支持QueueingConsumer。
5. QueueingConsumer不是事件驱动的。

## 传输保障

消息中间件的传输保障分为三个层级：

1. `At most once`：最多一次。消息可能丢失，但绝不会重复传输。
2. `At least once`：最少一次。消息绝不会丢失，但可能会重复传输。
3. `Exactly once`：恰巧一次。每条消息肯定会被传输一次并且仅传输一次。

### 保障方式

第一层比较简单，生产者随意发，消费者随意消费。

第二层：

1. 生产者开启确认机制，确保消息发送到了mq服务器。
2. 生产者使用mandatory或者备份交换器保证消息能被路由到队列。
3. 消息和队列都持久化，保证服务器异常重启不会丢失消息。
4. 消费者消费是autoAck设置成false，手动确认消息已消费。

第三层mq本身没有机制保障，可以用幂等校验或者redis来去重。

## 持久化

交换器，队列，消息全部持久化，消息也有丢失的情况。
1. 消息者设置autoAck=true，在处理消息之前宕机。
2. 数据在操作系统缓存中，还未落盘时宕机。

### 持久层

1. 处理消息的落盘：
   1. 持久化的消息在到达队列时就被写入到磁盘，在内存中也保存一份，在内存吃紧时从内存删除。
   2. 非持久化的消息一般只保存在内存中 ，在内存吃紧的时候会被换入到磁盘中，以节省内存空间。
2. 是一个逻辑上的概念，实际包含两个部分：队列索引**rabbit_queue_index**和消息存储**rabbit_msg_store**。

#### rabbit_queue_index

##### 作用

维护队列中落盘消息的信息：消息的存储地点、是否己交付、是 ack 等。

##### 结构

顺序的段文件，**从0开始，后缀为.idx**。

##### 特点

1. 每个段文件都包含固定的 **SEGMENT_ENTRY_COUNT** 条记录，默认是16384。
2. rabbit_queue_index 从磁盘载入内存是以**段文件**为单位的。
3. 消息的大小小于 **queue_index_embed_msgs_below** 时，默认4096B。消息体在rabbit_queue_index中，否则存储在rabbit_msg_store中。

#### rabbit_msg_store

##### 作用

以键值对的形式存储消息，它被所有队列共享，在每个节点中有且只有一个。

##### 结构

1. 分为**msg_store_persistent**和**msg_store_transient**。
   1. msg_store_persistent：负责持久化消息的持久化，重启后消息不会丢失。
   2. msg_store_transient：负责非持久化消息的持久化，重启后消息会丢失。
2. 顺序的文件，**从0开始，后缀为.rdq**。

##### 特点

1. 消息都会以追加的方式写入到文件中，当文件大小超过指定限制 **file_size_limit** 后，创建一个新文件继续写入。
2. 存储时， 在 **ETS** （Erlang Term Storage）表中记录消息在文件中的位置映射 **index** 和文件的相关信息 **FileSummary**。

### 消息读取

根据**消息ID**（msg_id）找到对应的存储文件：

1. 如果文件存在并且未被锁住，则直接打开文件，从指定位置读取消息的内容。
2. 如果文件不存在或者被锁住了，则发送请求由 **rabbit_msg_store** 进行处理。

### 消息删除

1. 只从 **ETS表** 删除消息相关信息，同时更新消息对应的存储文件的相关信息。标为垃圾数据。
2. 当一个文件中都是垃圾数据时将这个文件删除 。
3. 垃圾回收：前后两个文件中的有效数据可以合并在一个文件中，所有的垃圾数据的大小和所有文件【至少三个】的数据大小的比值超过设置的阈值 **GARBAGE_FRACTION** ，默认0.5。
   1. 先对前面文件中的有效数据进行整理。
   2. 将后面文件的有效数据写入到前面的文件，同时更新消息在 **ETS表** 中的记录。
   3. 最后删除后面的文件。

## 基本操作

```java
new AMQP.BasicProperties().builder().expiration("6000").timestamp().build()
```

### 消息属性

1. content-type：让消费者知道如何解释消息体。

2. content-encoding：指示消息体使用某种特殊的方式进行压缩或编码。

3. message-id：唯一消息标识。可以用于去重。

4. correlation-id：消息响应标识。可以用于拓扑排序。

5. timestamp：表示消息创建时间。

6. expiration：表示消息的过期时间。
   1. UNIX纪元时间或整数时间戳，然后把它存储为字符串。精度是毫秒。
   2. 已经超时的消息发布到服务器，不会被路由到任何队列，而是被直接丢弃。

7. delivery-mode：

   1. 将消息写入磁盘或内存队列。`1`：非持久化消息。`2`：持久化消息。
   2. 不持久化的影响：rabbitmq重启时，消息会丢失。队列和消息都设置持久化才有意义。

8. app-id和user-id：帮助追踪出现问题的消息发布者应用程序。

9. type：

   1. 表示发布者和消费者之间的契约。
   2. 一般可以用于描述消息中的内容，应用程序可以根据它来确定如何处理一个消息。

10. reply-to：实现响应消息的路由。

11. headers：定义自由格式的属性和实现RabbitMQ路由。

    1. key可以是ASCII或Unicode字符串，最大长度为255个字符。
    2. value可以是任何有效的AMQP值类型。

12. priority：消息优先级

    值被定义为0~9之间。用于指定队列中消息的优先级。**不建议使用**。

## 应用

### RPC实现【Remote Procedure Call】

#### 过程

1. 用到两个属性：`relayTo` 和 `correlationId`。
2. 客户端启动时，创建回调队列。
3. 客户端为RPC请求设置两个属性：
   1. `relayTo` 用来告知RPC服务端回复请求时的目的队列，即回调队列。
   2. `correlationId` 用来标记一个请求。
4. 请求被发送到 `rpc` 队列。
5. 服务器监听 `rpc` 队列，当请求来到时，服务端处理请求，并将根据 `relayTo` 将结果发到回调队列，携带 `correlationId` 。
6. 客户端监听回调队列，当有消息时，检查 `correlationId` ，如果匹配，拿到结果。

![](/Users/sunchen/Documents/notes/中间件/rabbitmq/实战指南/imgs/rpc实现.png)

#### [参考代码](exercises/src/main/java/com/rpc)
