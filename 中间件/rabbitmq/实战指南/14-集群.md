# 集群

## 概念

## 集群搭建

### 多机多节点

1. 配置各个节点的hosts文件，添加节点名称与ip地址的映射信息。

2. 编辑rabbitmq的cookie文件：

   1. 各个节点改成一样的值。
   2. 节点需要通过交换密钥令牌以获得相互认证，如果不一样join的时候会报错。
   3. 默认路径：`$HOME/.erlang.cookie`。

3. 配置集群：

   1. 有三种方式：**通过rabbitmqctl工具**，修改rabbitmq.config，通过Rabbitmq-autocluster插件配置。

   2. rabbitmqctl工具配置： 

      1. 启动各个节点

          ```shell
          rabbitmq-server -detached
          ```

      2. 以第一个节点为基准，把其他节点加入到第一个节点。

          ```shell
          rabbitmqctl stop_app
          rabbitmqctl reset
          rabbitmqctl join_cluster rabbitmq@node1
          rabbitmqctl start_app
          ```

4. 如果关闭了集群的所有节点，再启动集群时，需要先启动最后一个关闭的节点，如果第一个启动的不是最后一个关闭的节点，需要等待最后一个关闭的节点启动，这个等待时间是30s。

### 集群节点类型

1. 集群中的每一个节点都保存了所有的队列、交换器、绑定关系、用户、权限和vhost的元数据信息。
2. 集群中的节点分为两类：内存节点【ram】和磁盘节点【disc】。

#### 磁盘节点【disc】

1. 单节点的集群中只有磁盘节点；多节点的集群至少有一个磁盘节点。
2. 集群中所有磁盘节点都崩溃时，集群可以继续发送和接收消息，但不能执行创建队列、交换器等修改元数据的操作。
3. 在集群中添加内存节点，要告知所有的磁盘节点。内存节点至少找到一个磁盘节点，就可以加入集群。
4. 为了保证集群信息的可靠性，建议全部使用磁盘节点。

#### 内存节点【ram】

1. 加入集群时指定为内存节点

   ```shell
   rabbitmqctl join_cluster rabbit@node1 --ram
   ```

2. 修改集群节点类型

   ```shell
   rabbitmqctl stop_app
   rabbitmqctl change_cluster_node_type {disc|ram}
   rabbitmqctl start_app
   ```

3. 在集群中创建队列，交换器或者绑定关系的时候，这些操作直到所有集群节点都成功提交元数据变更才返回，故内存节点可以提供出色的性能。

4. 内存节点重启后，会连接到预先配置的磁盘节点，下载集群元数据的副本。


### 剔除节点

以node1、node2、node3集群为例，剔除node2

#### 方法一

1. 在node2上执行

   ````shell
   rabbitmqctl stop_app
   ````

2. 在node1或者node3上执行

   ```shell
   rabbitmqctl forget_cluster_node rabbit@node2 [-offline]
   ```

   1. 不加offline：需要节点在运行状态下。
   2. 加offline：节点可以在离线状态下。比如集群关闭顺序为：node3、node2、node1。可以在节点node2上执行forget_cluster_node来剔除node1。

#### 方法二

在node2上执行

```
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app
```

### 单机多节点

```shell
# 启动
RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit1 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15672}]" rabbitmq-server -detached
RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit2 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15673}]" rabbitmq-server -detached
RABBITMQ_NODE_PORT=5674 RABBITMQ_NODENAME=rabbit3 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15674}]" rabbitmq-server -detached

# 加入集群
rabbitmqctl -n rabbit1@sunchendeMacBook-Pro-2 stop_app
rabbitmqctl -n rabbit1@sunchendeMacBook-Pro-2 reset
rabbitmqctl -n rabbit1@sunchendeMacBook-Pro-2 join_cluster rabbit1@zhangshuai24deMacBook-Pro
rabbitmqctl -n rabbit2@sunchendeMacBook-Pro-2 start_app
rabbitmqctl -n rabbit2@sunchendeMacBook-Pro-2 stop_app
rabbitmqctl -n rabbit3@sunchendeMacBook-Pro-2 reset
rabbitmqctl -n rabbit3@sunchendeMacBook-Pro-2 join_cluster rabbit1@zhangshuai24deMacBook-Pro
rabbitmqctl -n rabbit3@sunchendeMacBook-Pro-2 start_app
```

## 节点升级

### 单节点集群升级

1. 关闭原来的服务
2. 新节点的mnesia路径指向与原节点相同。
3. 解压新版本运行

### 多节点集群升级

1. 关闭所有的节点的服务，注意采用rabbitmqctl stop命令关闭。
2. 保存各个节点的mnesia数据。
3. 解压新版本的rabbitmq到指定的目录。
4. 指定新版本的mnesia路径为步骤2中保存的mnesia数据路径。
5. 启动新版本的服务，注意先启动原版本中最后关闭的节点。

## 集群迁移

### 元数据重建

指在新的集群中创建原集群的队列、交换器、绑定关系、vhost、用户、权限和Parameter等数据信息。

#### 高效率重建

1. 从web管理页面上下载旧的原数据json。
2. 将json在新的集群web管理页面进行上传。

#### 需要考虑三个问题

1. 旧的开启management插件的节点故障不可修复，无法获取元数据 `metadata.json`。

   采取一个通用的备份任务，在元数据有变更或者达到某个存储周期时将最新的 `metadata.json` 备份至另一处安全的地方。

2. Mq版本不一致，上传失败。

   1. 密码加密方式不同：可通过命令修改密码解决。
   2. 其他问题：
      1. 手工在新集群中建立出队列、交换器、绑定关系的其他元数据（用户、策略、权限）。
      2. 从新创建好的集群中下载文件，复制queues之前的配置到旧的配置文件中，将旧的配置文件上传的新创建的集群中。

3. 将元数据在新集群上重建，则所有的队列都只会落到同一个集群节点上，而其他节点处于空置状态。

   通过代码解析json，将队列分散创建在不同节点上。

   1. [以channel方式迁移](exercises/src/main/java/com/cluster/metaTransfer/TransferWithChannel.java)
   2. [以http接口方式迁移](exercises/src/main/java/com/cluster/metaTransfer/TransferWithHttp.java)

   个人分析：只需分散建立队列即可，交换器、绑定关系只属于元数据。

### 数据迁移

使用Federation 或者 Shove 插件先从原集群把未消息的消息消费出来，再发送给新集群。

### 客户端连接切换

生产者客户端直接与原集群断开，连接新集群。

消费者客户端可以先消费完原集群的消息，再切换到新集群；如果原集群故障，可以先切到新集群，等原集群恢复后，使用Federation 或者 Shove 插件先从原集群把未消息的消息消费出来，再发送给新集群。

## 自动化迁移

将集群分为三部分：客户端，zookeeper，集群。

<img src="imgs/自动化迁移.jpg" alt="自动化迁移" style="zoom:50%;" />

生产者发消息时：

1. 先连接 zookeeper。
2. 根据路径 `rmqNode/exchanges/exchangeName`  读取该节点的数据，并对此节点添加 watcher。
3. 从数据中找到交换器所在集群名称`cluster = clusterName` ，根据路径`rmqNode/clusters/clusterName` 读取集群节点的数据。拿到ipList。
4. lP 地址列表、 vhost、 userName、password 等都已获取。
5. 客户端与集群建立连接。

消费者接收消息时：

1. 先连接zookeeper。
2. 根据路径 `rmqNode/exchanges/queueName`  读取该节点的数据，并对此节点添加 watcher。
3. 从数据中找到交换器所在集群名称`cluster = clusterName` ，根据路径`rmqNode/clusters/clusterName` 读取集群节点的数据。拿到ipList。
4. lP 地址列表、 vhost、 userName、password 等都已获取，客户端与集群建立连接。

集群切换时：

1. 在新的 cluster 上重建旧的 cluster 上的元数据。

2. 先变更交换器相关的 ZooKeeper 中的节点数据。【**切换生产者**】

3. 待原集群中的所有队列都消费完全之后，再将队列相关的 ZooKeeper 中的节点数据变更。【**切换消费者**】

4. 查看是否有队列中的消息未被消费完：

   ```shell
   rabbitmqctl list queues -p / -q I awk '{if($2>0) print $0}'
   ```

上面的自动化迁移立足于将现有集群迁移到空闲的备份集群。

### 循环备份

<img src="imgs/循环备份.jpg" alt="循环备份" style="zoom:50%;" />

### 以一备二

<img src="imgs/以一备二.jpg" alt="以一备二" style="zoom:50%;" />

## 集群监控

[参考代码](exercises/src/main/java/com/cluster/monitor)

## 镜像队列

- 如果消费者与 slave 建立连接井进行订阅消费，其实质上都是从 master 上获取消息，只不过看似是从 slave 上消费而己。

- 比如消费者与 slave 建立了 TCP 连接之后执行一个 Basic.Get的操作，那么首先是由 slave 将 Basic.Get 请求发往 master ，再由 master 准备好数据返回给slave ，最后由 slave 投递给消费者。

### 结构

<img src="imgs/主从结构.png" alt="主从结构" style="zoom:100%;" />

- 发送到镜像队列的所有消息会被同时发往 master 和所有的 slave 上，如果此时 master 挂掉了，消息还会在 slave 上，这样 slave提升为 master 的时候消息也不会丢失。
- 除发送消息 (Basic.Publish) 外的所有动作都只会master 发送，然后再由 master 将命令执行的结果广播给各个 slave。

<img src="imgs/镜像队列结构.png" alt="镜像队列结构" style="zoom:50%;" />

1. backing_queue：队列内容的实现模块。

   - master的 backing_queue 实现是 rabbit_mirror_queue_master。

   - slave的 backing_queue 实现是 rabbit_mirror_queue_slave。

2. rabbit_mirror_queue_slave 负责回调处理，而 master 上的回调处理是由 coordinator 负责完成的。

3. GM：负责消息的广播。实现的是一种可靠的组播通信协议，能够保证组播消息的原子性，保证组中活着的节点要么都收到消息要么都收不到。

   - 将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点。
   - 当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上。
   - 当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。
   - 这个组的信息会记录在Mnesia 中。不同的镜像队列形成不同的组。
   - 操作命令从 master 对应的 GM 发出后，顺着链表传送到所有的节点。由于所有节点组成了一个循环链表， master 对应的 GM 最终会收到自己发送的操作命令，这个时候 master 就知道该操作命令都同步到了所有的 slave 上。

### 镜像队列节点挂掉

- slave节点挂掉

  与 slave 连接的客户端连接全部断开。

- master节点挂掉：

  1. 与 master 连接的客户端连接全部断开。

  2. 选举最老的 slave 作为新的 master。

  3. 新的 master 重新入队所有 unack 的消息。

  4. 如果客户端连接着 slave ，并且 Basic.Consume 消费时指定了 x-cancel-on-ha-failover 参数，那么断开之时客户端会收到一个 Consumer Cancellation Notification 的通知，消费者客户端中会回调 Consumer 接口的 handleCancel 方法。

     ```java
     args.put("x-cancel-on-ha-failover" , true);
     ```

### 设置镜像队列

```shell
# 通过Policy方式来设置
rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue "pattern" ' {"ha-mode":"exactly", "ha-params ": 2,"ha-sync-mode ": "automatic" },
```

1. ha-mode：镜像队列的模式。**对排他队列不生效。**
   - all：在集群中所有的节点上进行镜像。
   - exactly：在指定个数的节点上进行镜像，节点个数由 ha-params 指定。
   - nodes：在指定节点上进行镜像，节点名称通ha-params 指定。
2. ha-params：不同的 ha-mode 配置中需要用到的参数。
3. ha-sync-mode：队列中消息的同步方式。
   - automatic：新加入的 slave 会默认同步已知的镜像队列。队列也会阻塞。
   - manual：【默认】，将新节点加入已存在的镜像队列时，不会主动同步到消息，需要显示调用同步命令。
     - 当调用同步命令后，队列开始阻塞，无法对其进行其他操作，直到同步完成。

### 相关命令

#### 同步队列

```shell
rabbitmqctl sync_queue {name)
```

#### 取消同步队列

```shell
rabbitmqctl cancel_sync_queue {name)
```

#### 查看哪些 slaves 已经完成同步

```shell
rabbitmqctl list_queues {name} slave_pids synchronised_slave_pids
```

## 网络分区

### 概念

一个分布式系统里面，节点组成的网络本来应该是连通的。但可能因为一些故障，有些节点之间不连通了，整个网络分成了几块区域。数据散布在了这些不连通的区域中。这就叫分区。

### 意义

与rabbitmq的数据一致性复制原理有关。rabbitmq的镜像队列是环形的逻辑结构，如果其中一个节点不可用，会导致整个集群不可用，引入网络分区，将不可用的节点剥离，保证可用性，等网络恢复，再加入集群。

### 判定方式

#### 人为判定方式

- 通过查看rabbitmq的服务日志：通过` running_partitioned_network` 关键字查看。

- 通过 `rabbitmqctl cluster_status`查看。

  ```shell
  [{nodes, [{disc, [rabbit@nodel, rabbit@node2, rabbit@node3]}]}, 
  {running_nodes, [rabbit@node3, rabbit@nodel]} , 
  {cluster_name, <<"rabbit@nodel">>} , 
  {partitions [{rabbit@node3, [rabbit@node2]} , {rabbit@nodel, [rabbit@node2]}]}]
  ```

  - 上面 partitions 项中的内容表示：
    - rabbit@node3 和 rabbit@node2 发生了分区，即 {rabbit@node3, [rabbit@node2]}
    - rabbit@node1 和 rabbit@node2 发生了分区，即 {rabbit@node1, [rabbit@node2]}

- 通过web管理界面查看：是否有 *network partition detected* 警告。

- 调用API查看

  ```shell
  #查看
  curl -i -u username:password -H "content-type:application/json" -X GET http://ip:port/api/nodes
  #内容
  "partitions":[ 
   	"rabbit@node2" 
  ]
  ```

#### 节点内部判定

如果连续4次某节点都没有被 ticked， 则可以判定该节点已 down，其余节点可将该节点剥离出当前分区。

##### 应答

1. RabbitMQ 集群内部的每个节点之间，会每隔四分之一的 net_ticktime 计一次应答。

2. 如果有任何数据被写入节点中，则该节点被认为已经被应答了。


##### net_ticktime

- 节点内部通信超时时间，默认60s。
- 将连续4次的 tick 时间记为T ，那么T的取值范围为 0.75 x net_ticktime < T < 1.25 x net_ticktime。

##### heartbeat_time

客户端与节点之间通信的心跳时间，默认60s。

### 网络分区模拟

- iptables 封禁/解封地址或者端口号

  1. 在某个节点进行封禁。`iptables -A INPUT -p tcp --dport 25672 -j DROP; iptables -A OUTPUT -p tcp --dport 25672 -j DROP`
  2. 查看日志。
  3. 解禁。`iptables -D INPUT 1; iptables -D OUTPUT 1`

- 关闭/开启网卡

  1. 查看网卡名称。`ifconfig`

  2. 在某个节点上关闭网卡。`ifdown <网卡名>`

  3. 查看日志，是否有分区。

  4. 开启网卡。`ifup <网卡名>`

- 挂起/恢复操作系统。

### 网络分区影响

#### 未配置镜像

对发送端的影响：

1. 消息可以发送，但是会路由失败，如果没有设置mandatory并且没有监听，则消息会丢失。
2. 后面加入的生产者，操作另一个分区的队列等会出现异常。

对消费端的影响：

1. 消费端没有异常报错，会有诡异现象，比如**已经消费的消息ack失效**。
2. 后面加入的消费者，操作另一个分区的队列等会出现异常。

#### 已配置镜像

会发生消息的丢失。以下过程可以最大程度的保证可用性和消息的可靠性：

1. 消息发送端要有处理 Basic.Return 的能力。
2. 分区后，能够迅速挂起所有生产者进程。
3. 连接每个节点，消费分区中的所有队列数据，会有大量消息重复，做好幂等。
4. ***处理网络分区***。
5. 恢复所有生产者进程。

## 处理网络分区

### 手动处理

#### 如何挑选信任分区

指标如下（优先级从上至下）：

1. 分区中要有disc节点
2. 节点数最多
3. 队列数最多
4. 客户端连接数最多

#### 如何重启节点

关闭：rabbitmqctl stop_app

启动：rabbitmqctl start_app

#### 重启顺序有何考究

先停止非信任节点，再重启这些节点，如果还有网络分区，再重启信任节点。

#### 步骤

1. 挂起生产者和消费者进程，减少消息不必要的丢失，**紧急情况可跳过此步骤**。
2. 删除镜像队列的配置。**避免队列漂移**。
3. 挑选信任分区。
4. 关闭非信任分区中的节点。
5. 启动非信任分区中的节点。
6. 检查网络分区是否恢复，如果恢复，跳过下一步。
7. 重启信任分区中的节点。
8. 添加镜像队列的配置。
9. 恢复生产者和消费者的进程。

### 自动处理

#### 默认

##### 配置

```json
[
	{
    rabbit, [
    	{cluster_partition_handling, ignore}
    ]
  }
].
```

##### 处理方式

不自动处理分区。

#### pause-minority 模式

##### 配置

```json
[
	{
    rabbit, [
    	{cluster_partition_handling, pause_minority}
    ]
  }
].
```

##### 处理方式

「少数派」分区中的节点会在分区开始时关闭，分区结束时开启。

如果一个集群中只有两个节点，则两个节点都会关闭。

#### pause-if-all-down 模式

##### 配置

```json
[
	{
    rabbit, [
    	{
        cluster_partition_handling, 
       	{pause_if_all_down, ['nodeName'], ignore}
      }
    ]
  }
].
```

##### 处理方式

当集群中的节点无法与配置中的节点通信，则自身自动关闭，在通信恢复后开启。

如果配置中的节点本身不可用，则集群中的节点都会关闭。

如果出现对等分区，可以把ignore改为autoheal，可以处理对等分区。

#### autoheal 模式

##### 配置

```json
[
	{
    rabbit, [
    	{cluster_partition_handling, autoheal}
    ]
  }
].
```

##### 处理方式

自动选取一个获胜分区，等网络恢复后，重启不在这个分区的其他节点。平局的话，用字典序来选择。

如果集群中有节点处于非运行状态，将不会自动处理。

### 模式挑选

ignore模式：发生网络分区时，不做任何动作，需要人工介入。

pause-minority 模式：对于对等分区的处理不够优雅，可能会关闭所有节点。可应用于非跨机架，奇数节点数的集群。

pause-if-all-down 模式：对于受信节点的选择尤为考究。尤其是在集群中所有节点硬件配置相同的情况下。此种模式可以处理对等分区的情形。

autoheal 模式：可以处理各个情形下的网络分区，但是如果集群中有节点处于非运行状态，则此中模式会失效。

## 管理

### 加入集群

```shell
rabbitmqctl join_cluster {cluster_node} [--ram]
```

### 状态

```shell
rabbitmqctl cluster_status
```

```text
Cluster status of node rabbit@localhost ...
Basics

Cluster name: rabbit@sunchendeMacBook-Pro

Disk Nodes

rabbit@localhost

Running Nodes

rabbit@localhost

Versions

rabbit@localhost: RabbitMQ 3.8.17 on Erlang 24.0.2

Maintenance status

Node: rabbit@localhost, status: not under maintenance

Alarms

(none)

Network Partitions

(none)

Listeners

Node: rabbit@localhost, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@localhost, interface: [::], port: 1883, protocol: mqtt, purpose: MQTT
Node: rabbit@localhost, interface: [::], port: 61613, protocol: stomp, purpose: STOMP
Node: rabbit@localhost, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@localhost, interface: 127.0.0.1, port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0

Feature flags

Flag: drop_unroutable_metric, state: disabled
Flag: empty_basic_get_metric, state: disabled
Flag: implicit_default_bindings, state: enabled
Flag: maintenance_mode_status, state: disabled
Flag: quorum_queue, state: enabled
Flag: user_limits, state: disabled
Flag: virtual_host_metadata, state: enabled
```

### 修改节点类型

```shell
rabbitmqctl change_cluster_node_type {disc|ram}
```

### 集群删除节点

```shell
rabbitmqctl forget_cluster_node [--offline]
```

1. 不加offline：需要节点在运行状态下。
2. 加offline：节点可以在离线状态下。比如集群关闭顺序为：node3、node2、node1。可以在节点node2上执行forget_cluster_node来剔除node1。

### 更新节点最新信息

```shell
rabbitmqctl update_cluster_nodes {clusterNode}
```

集群中的节点应用启动前咨询节点的最新信息，并更新相应的集群信息，不加入集群。

### 强制启动

```shell
rabbitmqctl force_boot
```

### 同步队列

```shell
rabbitmqctl sync_queue [-p vhost] {queue}
```

指示未同步队列queue的slave镜像可以同步master镜像的内容。同步期间阻塞，直到同步完成。

### 取消同步队列

```shell
rabbitmqctl cancel_sync_queue [-p vhost] {queue}
```

### 设置集群名称

```shell
rabbitmqctl set_cluster_name {name}
```

## 配置

文件配置：rabbitmq.conf

|           变量名           | 含义                                                         |
| :------------------------: | ------------------------------------------------------------ |
| cluster_partition_handling | 如何处理网络分区。                                           |
| cluster_keepalive_interval | 向其他节点发送存活消息的频率。单位为毫秒。默认100000。       |
|       cluster_nodes        | 可以用来配置集群。二元组，一个是要加入集群的节点名称，一个是节点类型。 |

## 
