# 集群

## 概念

## 集群搭建

### 多机多节点

1. 配置各个节点的hosts文件，添加节点名称与ip地址的映射信息。

2. 编辑rabbitmq的cookie文件：

   1. 各个节点改成一样的值。
   2. 节点需要通过交换密钥令牌以获得相互认证，如果不一样join的时候会报错。
   3. 默认路径：`$HOME/.erlang.cookie`。

3. 配置集群：

   1. 有三种方式：**通过rabbitmqctl工具**，修改rabbitmq.config，通过Rabbitmq-autocluster插件配置。

   2. rabbitmqctl工具配置： 

      1. 启动各个节点

          ```shell
          rabbitmq-server -detached
          ```

      2. 以第一个节点为基准，把其他节点加入到第一个节点。

          ```shell
          rabbitmqctl stop_app
          rabbitmqctl reset
          rabbitmqctl join_cluster rabbitmq@node1
          rabbitmqctl start_app
          ```

4. 如果关闭了集群的所有节点，再启动集群时，需要先启动最后一个关闭的节点，如果第一个启动的不是最后一个关闭的节点，需要等待最后一个关闭的节点启动，这个等待时间是30s。

### 集群节点类型

1. 集群中的每一个节点都保存了所有的队列、交换器、绑定关系、用户、权限和vhost的元数据信息。
2. 集群中的节点分为两类：内存节点【ram】和磁盘节点【disc】。

#### 磁盘节点【disc】

1. 单节点的集群中只有磁盘节点；多节点的集群至少有一个磁盘节点。
2. 集群中所有磁盘节点都崩溃时，集群可以继续发送和接收消息，但不能执行创建队列、交换器等修改元数据的操作。
3. 在集群中添加内存节点，要告知所有的磁盘节点。内存节点至少找到一个磁盘节点，就可以加入集群。
4. 为了保证集群信息的可靠性，建议全部使用磁盘节点。

#### 内存节点【ram】

1. 加入集群时指定为内存节点

   ```shell
   rabbitmqctl join_cluster rabbit@node1 --ram
   ```

2. 修改集群节点类型

   ```shell
   rabbitmqctl stop_app
   rabbitmqctl change_cluster_node_type {disc|ram}
   rabbitmqctl start_app
   ```

3. 在集群中创建队列，交换器或者绑定关系的时候，这些操作直到所有集群节点都成功提交元数据变更才返回，故内存节点可以提供出色的性能。

4. 内存节点重启后，会连接到预先配置的磁盘节点，下载集群元数据的副本。


### 剔除节点

以node1、node2、node3集群为例，剔除node2

#### 方法一

1. 在node2上执行

   ````shell
   rabbitmqctl stop_app
   ````

2. 在node1或者node3上执行

   ```shell
   rabbitmqctl forget_cluster_node rabbit@node2 [-offline]
   ```

   1. 不加offline：需要节点在运行状态下。
   2. 加offline：节点可以在离线状态下。比如集群关闭顺序为：node3、node2、node1。可以在节点node2上执行forget_cluster_node来剔除node1。

#### 方法二

在node2上执行

```
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app
```

### 单机多节点

```shell
# 启动
RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit1 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15672}]" rabbitmq-server -detached
RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit2 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15673}]" rabbitmq-server -detached
RABBITMQ_NODE_PORT=5674 RABBITMQ_NODENAME=rabbit3 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15674}]" rabbitmq-server -detached

# 加入集群
rabbitmqctl -n rabbit2@zhangshuai24deMacBook-Pro stop_app
rabbitmqctl -n rabbit2@zhangshuai24deMacBook-Pro reset
rabbitmqctl -n rabbit2@zhangshuai24deMacBook-Pro join_cluster rabbit1@zhangshuai24deMacBook-Pro
rabbitmqctl -n rabbit2@zhangshuai24deMacBook-Pro start_app
rabbitmqctl -n rabbit3@zhangshuai24deMacBook-Pro stop_app
rabbitmqctl -n rabbit3@zhangshuai24deMacBook-Pro reset
rabbitmqctl -n rabbit3@zhangshuai24deMacBook-Pro join_cluster rabbit1@zhangshuai24deMacBook-Pro
rabbitmqctl -n rabbit3@zhangshuai24deMacBook-Pro start_app
```

## 节点升级

### 单节点集群升级

1. 关闭原来的服务
2. 新节点的mnesia路径指向与原节点相同。
3. 解压新版本运行

### 多节点集群升级

1. 关闭所有的节点的服务，注意采用rabbitmqctl stop命令关闭。
2. 保存各个节点的mnesia数据。
3. 解压新版本的rabbitmq到指定的目录。
4. 指定新版本的mnesia路径为步骤2中保存的mnesia数据路径。
5. 启动新版本的服务，注意先启动原版本中最后关闭的节点。

## 集群迁移

### 元数据重建

指在新的集群中创建原集群的队列、交换器、绑定关系、vhost、用户、权限和Parameter等数据信息。

#### 高效率重建

1. 从web管理页面上下载旧的原数据json。
2. 将json在新的集群web管理页面进行上传。

#### 需要考虑三个问题

1. 旧的开启management插件的节点故障不可修复，无法获取元数据 `metadata.json`。

   采取一个通用的备份任务，在元数据有变更或者达到某个存储周期时将最新的 `metadata.json` 备份至另一处安全的地方。

2. Mq版本不一致，上传失败。

   1. 密码加密方式不同：可通过命令修改密码解决。
   2. 其他问题：
      1. 手工在新集群中建立出队列、交换器、绑定关系的其他元数据（用户、策略、权限）。
      2. 从新创建好的集群中下载文件，复制queues之前的配置到旧的配置文件中，将旧的配置文件上传的新创建的集群中。

3. 将元数据在新集群上重建，则所有的队列都只会落到同一个集群节点上，而其他节点处于空置状态。

   通过代码解析json，将队列分散创建在不同节点上。

   1. [以channel方式迁移](exercises/src/main/java/com/cluster/metaTransfer/TransferWithChannel.java)
   2. [以http接口方式迁移](exercises/src/main/java/com/cluster/metaTransfer/TransferWithHttp.java)

   个人分析：只需分散建立队列即可，交换器、绑定关系只属于元数据。

### 数据迁移

使用Federation 或者 Shove 插件先从原集群把未消息的消息消费出来，再发送给新集群。

### 客户端连接切换

生产者客户端直接与原集群断开，连接新集群。

消费者客户端可以先消费完原集群的消息，再切换到新集群；如果原集群故障，可以先切到新集群，等原集群恢复后，使用Federation 或者 Shove 插件先从原集群把未消息的消息消费出来，再发送给新集群。

## 自动化迁移

将集群分为三部分：客户端，zookeeper，集群。

<img src="imgs/自动化迁移.jpg" alt="自动化迁移" style="zoom:50%;" />

生产者发消息时：

1. 先连接zookeeper。
2. 根据路径 `rmqNode/exchanges/exchangeName`  读取该节点的数据，并对此节点添加 watcher。
3. 从数据中找到交换器所在集群名称`cluster = clusterName` ，根据路径`rmqNode/clusters/clusterName` 读取集群节点的数据。拿到ipList。
4. lP 地址列表、 vhost、 userName、password 等都已获取。
5. 客户端与集群建立连接。

消费者接收消息时：

1. 先连接zookeeper。
2. 根据路径 `rmqNode/exchanges/queueName`  读取该节点的数据，并对此节点添加 watcher。
3. 从数据中找到交换器所在集群名称`cluster = clusterName` ，根据路径`rmqNode/clusters/clusterName` 读取集群节点的数据。拿到ipList。
4. lP 地址列表、 vhost、 userName、password 等都已获取，客户端与集群建立连接。

集群切换时：

1. 在新的 cluster 上重建旧的 cluster 上的元数据。

2. 先变更交换器相关的 ZooKeeper 中的节点数据。【**切换生产者**】

3. 待原集群中的所有队列都消费完全之后，再将队列相关的 ZooKeeper 中的节点数据变更。【**切换消费者**】

4. 查看是否有队列中的消息未被消费完：

   ```shell
   rabbitmqctl list queues -p / -q I awk '{if($2>0) print $0}'
   ```

上面的自动化迁移立足于将现有集群迁移到空闲的备份集群。

### 循环备份

<img src="imgs/循环备份.jpg" alt="循环备份" style="zoom:50%;" />

### 以一备二

<img src="imgs/以一备二.jpg" alt="以一备二" style="zoom:50%;" />

## 管理

### 加入集群

```shell
rabbitmqctl join_cluster {cluster_node} [--ram]
```

### 状态

```shell
rabbitmqctl cluster_status
```

```text
Cluster status of node rabbit@localhost ...
Basics

Cluster name: rabbit@sunchendeMacBook-Pro

Disk Nodes

rabbit@localhost

Running Nodes

rabbit@localhost

Versions

rabbit@localhost: RabbitMQ 3.8.17 on Erlang 24.0.2

Maintenance status

Node: rabbit@localhost, status: not under maintenance

Alarms

(none)

Network Partitions

(none)

Listeners

Node: rabbit@localhost, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@localhost, interface: [::], port: 1883, protocol: mqtt, purpose: MQTT
Node: rabbit@localhost, interface: [::], port: 61613, protocol: stomp, purpose: STOMP
Node: rabbit@localhost, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@localhost, interface: 127.0.0.1, port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0

Feature flags

Flag: drop_unroutable_metric, state: disabled
Flag: empty_basic_get_metric, state: disabled
Flag: implicit_default_bindings, state: enabled
Flag: maintenance_mode_status, state: disabled
Flag: quorum_queue, state: enabled
Flag: user_limits, state: disabled
Flag: virtual_host_metadata, state: enabled
```

### 修改节点类型

```shell
rabbitmqctl change_cluster_node_type {disc|ram}
```

### 集删除节点

```shell
rabbitmqctl forget_cluster_node [--offline]
```

1. 不加offline：需要节点在运行状态下。
2. 加offline：节点可以在离线状态下。比如集群关闭顺序为：node3、node2、node1。可以在节点node2上执行forget_cluster_node来剔除node1。

### 更新节点最新信息

```shell
rabbitmqctl update_cluster_nodes {clusterNode}
```

集群中的节点应用启动前咨询节点的最新信息，并更新相应的集群信息，不加入集群。

### 强制启动

```shell
rabbitmqctl force_boot
```

### 同步队列

```shell
rabbitmqctl sync_queue [-p vhost] {queue}
```

指示未同步队列queue的slave镜像可以同步master镜像的内容。同步期间阻塞，直到同步完成。

### 取消同步队列

```shell
rabbitmqctl cancel_sync_queue [-p vhost] {queue}
```

### 设置集群名称

```shell
rabbitmqctl set_cluster_name {name}
```

## 配置

文件配置：rabbitmq.conf

|           变量名           | 含义                                                         |
| :------------------------: | ------------------------------------------------------------ |
| cluster_partition_handling | 如何处理网络分区。                                           |
| cluster_keepalive_interval | 向其他节点发送存活消息的频率。单位为毫秒。默认100000。       |
|       cluster_nodes        | 可以用来配置集群。二元组，一个是要加入集群的节点名称，一个是节点类型。 |

## 镜像队列

- 如果消费者与 slave 建立连接井进行订阅消费，其实质上都是从 master 上获取消息，只不过看似是从 slave 上消费而己。

- 比如消费者与 slave 建立了 TCP 连接之后执行一个 Basic.Get的操作，那么首先是由 slave 将 Basic.Get 请求发往 master ，再由 master 准备好数据返回给slave ，最后由 slave 投递给消费者。

### 结构

<img src="imgs/主从结构.png" alt="主从结构" style="zoom:100%;" />

- 发送到镜像队列的所有消息会被同时发往 master 和所有的 slave 上，如果此时 master 挂掉了，消息还会在 slave 上，这样 slave提升为 master 的时候消息也不会丢失。
- 除发送消息 (Basic.Publish) 外的所有动作都只会master 发送，然后再由 master 将命令执行的结果广播给各个 slave。

<img src="imgs/镜像队列结构.png" alt="镜像队列结构" style="zoom:50%;" />

1. backing_queue：队列内容的实现模块。

   - master的 backing_queue 实现是 rabbit_mirror_queue_master。

   - slave的 backing_queue 实现是 rabbit_mirror_queue_slave。

2. rabbit_mirror_queue_slave 负责回调处理，而 master 上的回调处理是由 coordinator 负责完成的。

3. GM：负责消息的广播。实现的是一种可靠的组播通信协议，能够保证组播消息的原子性，保证组中活着的节点要么都收到消息要么都收不到。

   - 将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点。
   - 当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上。
   - 当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。
   - 这个组的信息会记录在Mnesia 中。不同的镜像队列形成不同的组。
   - 操作命令从 master 对应的 GM 发出后，顺着链表传送到所有的节点。由于所有节点组成了一个循环链表， master 对应的 GM 最终会收到自己发送的操作命令，这个时候 master 就知道该操作命令都同步到了所有的 slave 上。

### 镜像队列节点挂掉

- slave节点挂掉

  与 slave 连接的客户端连接全部断开。

- master节点挂掉：

  1. 与 master 连接的客户端连接全部断开。

  2. 选举最老的 slave 作为新的 master。

  3. 新的 master 重新入队所有 unack 的消息。

  4. 如果客户端连接着 slave ，并且 Basic.Consume 消费时指定了 x-cancel-on-ha-failover 参数，那么断开之时客户端会收到一个 Consumer Cancellation Notification 的通知，消费者客户端中会回调 Consumer 接口的 handleCancel 方法。

     ```java
     args.put("x-cancel-on-ha-failover" , true);
     ```

### 设置镜像队列

```shell
# 通过Policy方式来设置
rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue "pattern" ' {"ha-mode":"exactly", "ha-params ": 2,"ha-sync-mode ": "automatic" },
```

1. ha-mode：镜像队列的模式。**对排他队列不生效。**
   - all：在集群中所有的节点上进行镜像。
   - exactly：在指定个数的节点上进行镜像，节点个数由 ha-params 指定。
   - nodes：在指定节点上进行镜像，节点名称通ha-params 指定。
2. ha-params：不同的 ha-mode 配置中需要用到的参数。
3. ha-sync-mode：队列中消息的同步方式。
   - automatic：新加入的 slave 会默认同步已知的镜像队列。队列也会阻塞。
   - manual：【默认】，将新节点加入已存在的镜像队列时，不会主动同步到消息，需要显示调用同步命令。
     - 当调用同步命令后，队列开始阻塞，无法对其进行其他操作，直到同步完成。

### 相关命令

#### 同步队列

```shell
rabbitmqctl sync_queue {name)
```

#### 取消同步队列

```shell
rabbitmqctl cancel_sync_queue {name)
```

#### 查看哪些 slaves 已经完成同步

```shell
rabbitmqctl list_queues {name} slave_pids synchronised_slave_pids
```

