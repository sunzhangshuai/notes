# 简介

## 消息中间件作用

1. 解耦。
2. 冗余【存储】。
3. 扩展性。
4. 削峰。
5. 可恢复性。
6. 顺序保证。
7. 缓冲。
8. 异步通信。

## RabbitMQ特点

1. 可靠性：持久化机制。
2. 路由灵活。
3. 扩展性：集群。
4. 高可用性：设置镜像。
5. 多种协议。
6. 多语言客户端。
7. 管理界面。`http://localhost:15672/#/`
8. 插件机制。

# 基础命令

## 启动

```shell
rabbitmq-server -detached
```

1. detached：以守护进程的方式在后台运行。

## 查看状态

```shell
rabbitmqctl status
```

## 查看集群信息

```shell
rabbitmqctl cluster_status
```

# 相关概念

## 消息

1. 消息体【payload】：带有业务逻辑的数据。
2. 标签【label】：表述消息，交换器、路由键。

## 生产者【Producer】

生产者发送的消息包含消息体和标签，RabbitMQ根据标签把消息发送给感兴趣的消费者。

## 消费者【Consumer】

1. 连接服务器，订阅到队列上。
2. 在消息路由的过程中，消息的标签会丢弃掉。队列中只有消息体。

## 服务节点【Broker】

## 队列【Queue】

1. 消息都只能存储在队列中，kafka是存储在主题逻辑层面。
2. 多个消费者可以订阅同一队列，队列中的消息会被平均分摊。
3. 不支持队列层面的广播。

## 交换器【Exchange】

生产者将消息发送到交换器，由交换器将消息路由到一个或多个队列。

## 路由键【RoutingKey】

## 绑定【Binging】

### 绑定键【BingingKey】

## 信道【Channel】

**AMQP**

1. 每个信道都会被指定一个唯一的ID。
2. 是建立在连接上的虚拟信道。多线程间复用TCP连接，起到节省作用。

## 交换器类型

### fanout

把所有发送到该交换机的消息路由到所有与该交换器绑定的队列中。

### direct

把消息路由到 BingdingKey 和 RoutingKey完全匹配的队列中。

### topic

把消息路由到  BingdingKey 和 RoutingKey 相匹配的队列中。

1. BingdingKey和RoutingKey 都是以`.`分隔的字符串。每一段称为一个单词。
2. BingdingKey存在两种特殊字符串，用于做模糊匹配。
   1. `*`：匹配一个单词。
   2. `#`：匹配多个单词。

### headers

1. 不依赖路由键的匹配规则。依赖headers属性。
2. 在绑定队列和交换器时制定一组键值对。
3. 对比消息中的headers是否完全匹配队列和交换器绑定时指定的键值对。
4. 性能很差，基本不用。

# 运转流程

## 生产者发消息的过程

1. 生产者连接到RabbitMQ实例，建立一个连接、开启一个信道。
2. 生产者声明交换器，设置相关属性：交换器类型、是否持久化等。
3. 生产者声明一个队列，设置相关属性：是否排他、是否持久化、是否自动删除等。
4. 生产者通过绑定键将交换器和队列绑定起来。
5. 生产者发送消息至RabbitMQ实例，其中包含路由键、交换器等信息。
6. 相应的交换器根据接受到的路由键查找相匹配的队列。找到就存入相应队列。
7. 关闭信道。
8. 关闭链接。

## 消费者接收消息的过程

1. 消费者连接到RabbitMQ实例，建立一个连接、开启一个信道。
2. 请求消费队列中的消息，可能设置相应的回调函数，做一些准备工作。
3. 等待实例回应并投递消息，消费者接收。
4. 消费者确认【ack】消息接受。
5. RabbitMQ从队列中删除已被确认的消息。
6. 关闭信道。
7. 关闭连接。

# AMQP协议

## 协议层

1. Module Layer：协议最高层，定义供客户端调用的命令。
2. Session Layer：
   1. 中间层，负责将客户端的命令发送给服务器，将应答返回给客户端。
   2. 为客户端与服务端之间的通信提供可靠性同步机制和错误处理。
3. Transport Layer：最底层，负责传输二进制数据流。
