# 插件

查看插件使用情况

```shell
rabbitmq-plugins list
```

1. [E*]：显式启动
2. [e*]：隐式启动
3. [ ]：没启动

## Management

1. [地址](http://localhost:15672)：http://localhost:15672
2. guest账户不可以访问远程web管理界面。
3. 非guest的非none账户可以访问远程web管理界面。

### 管理

#### 启动

```shell
rabbitmq-plugins enable rabbitmq_management
```

### 关闭

```shell
rabbitmq-plugins disable rabbitmq_management
```

## Federation

数据转发功能。

### 管理

#### 启动

```shell
rabbitmq-plugins enable rabbitmq_federation
```

默认会开启 **amqp_client** 插件。

#### 启动Federation管理插件

```
rabbitmq-plugins enable rabbitmq_federation_management
```

1. 依附于 **rabbitmq_management** 插件。

2. 在 RabbitMQ 管理界面中"Admin" 的右侧会多出 "Federation Status" 和 "Federation Upstreams" 两个 Tab 页。

#### 查看federation信息

```shell
rabbitmqctl eval 'rabbit_federation_status:status().'
```

### 使用

node2消费发送到node1的消息。

1.  node1, node2 中开启 rabbitmq_federation 插件，最好同时开启 rabbitmq_federation_management 插件。

2. 在node2 中定义一个 upstream

   1. ```shell
      rabbitmqctl set_parameter federation-upstream upstreamName '{"uri":"amqp://username:password@ip:port", "ack-mode":"on-confirm" }' 
      ```

   2. 通过在 Web 管理界面中添加的方式，在 "Admin" -> "Federation Upsteams" -> "Add a new upstream" 中创建。

   3. 参数

      1. name：upstream名称
      2. uri：定义upstream的AMQP的连接。
      3. prefetch_count：定义 Federation 内部缓存的消息条数，即在收到上游消息之后，在发送到下游之前缓存的消息条数。
      4. reconnect-delay：Federation link 由于某种原因断开之后，需要等待多少秒开始重新建立连接。
      5. ack-mode：Federation link 的消息确认方式。
         1. on-confirm：**todo**
         2. on-publish
         3. no-ack
      6. trust-user-id：设定 Federation 是否使用 "Validated User-ID"个功能。默认为false。
      7. 只适合 federated exchange 的参数
         1. exchange：指定 upstream exchange 的名称，**默认情况下和 federated exchange 同名**。
         2. max-hops：指定消息被丢弃前在 Federation link 中最大的跳转次数，**默认为1**。
         3. expires：指定 Federation link 断开之后，federated queue 所对应的 upstream queue 的超时时间，**默认为"none"**。
         4. message-ttl：federated queue 所对应的 upsteam queue 设置，相当于普通队列的 x-message-ttl 参数。**默认为 "none"**。
         5. ha-policy：federated queue 所对应的 upsteam queue 设置，相当于普通队列的 x-ha-policy参数，**默认为 "none"**。
      8. queue参数
         1. queue：指定 upstream queue 的名称，默认情况下和 federated queue 同名。

3. 定义一个 Policy 用于匹配交换器 exchangeA ，并使用第二步中所创建的 upstream。

   1. ```shell
      rabbitmqctl set_policy --apply-to {exchanges|queues} policyName "pattern" '{"federation-upstream": upstreamName}'
      ```

   2. 通过 Web 理界面中添加的 ，在 "Admin" -> "Policies" ->  "Add/ update a policy" 下创建。

   3. 参数：

      1. name：策略名称。
      2. pattern：交换器或者队列的匹配规则。
      3. apply-to：应用于交换器、队列、交换器和队列。
      4. priority：策略优先级。
      5. definition：参数定义。
         1. federation-upstream：上游名称。
         2. federation-upstream-set：all-全部上游。

### 联邦交换机

node2指定node1为upstream后。

#### 交换机及队列创建过程

1. 在node2上创建交换器`exchangeName`，mq会在node1上自动创建同名交换器`exchangeName`

2. 在node2上创建队列`queueName` ，并用`key1`绑定`exchangeName`，会在node1上自动创建内部交换器`federation:exchangeName -> node1 B`、用`key1`和同名交换器进行绑定，并自动创建队列`federation:exchangeName -> node1`，该队列只可读，不可写。

#### 消息流转

<img src="imgs/联邦交换器.png" alt="联邦交换器" style="zoom:50%;" />

#### 拓扑逻辑部署方式

1. 三足鼎立
2. "fan-out" 的多叉树形式
3. 环形

#### 优点

1. 异地均摊消费。

   内部队列在有消费者时，会将一半给消费者消费，一半发给下游。

2. 解决网络延迟。

#### [参考代码](exercises/src/main/java/com/federation/exchange)

### 联邦队列

node2指定node1为upstream后。

#### 消息流转

<img src="imgs/联邦队列.png" alt="联邦队列" style="zoom:50%;" />

#### 特点

1. 在当前队列中的消息消费完之后，会拉取上游队列中的消息存储到本地，由消费者进行消费。
2. 一条消息可以在联邦间被转发无数次。
3. 联邦队列不具备传递性。

#### [参考代码](exercises/src/main/java/com/federation/queue)

## shovel

1. 能够可靠、持续地从源端队列拉取数据并转发至目的端交换器。
2. 源端队列和目的端交换器可以位于同一个 Broker 上，也可以位于不同的 Broker 上。

### 优势

1. 松耦合：源端和目的端的管理域、节点或集群、用户、vhost、Erlang 版本均可不同。
2. 支持广域网： Broker 之间基于 AMQP 协议进行通信，有重连机制保证消息的可靠性。
3. 高度定制：当 Shove 成功连接后，可以对其进行配置以执行相关的 AMQP 命令。

### 管理

#### 启动

```shell
rabbitmq-plugins enable rabbitmq_shovel
```

默认会开启 **amqp_client** 插件。

#### 启动Shovel管理插件

```
rabbitmq-plugins enable rabbitmq_shovel_management
```

1. 依附于 **rabbitmq_management** 插件。
2. 在 RabbitMQ 管理界面中"Admin" 的右侧会多出 "Shovel Status" 和 "Shovel  Managment" 两个 Tab 页。

#### 查看shovel信息

```shell
rabbitmqctl eval 'rabbit_shovel_status:status().'
```

### 消息流转

|  源端  | 目的端 |                            示意图                            | 描述                                                         |
| :----: | :----: | :----------------------------------------------------------: | ------------------------------------------------------------ |
| 交换器 | 交换器 | <img src="imgs/shovel3.png" alt="shovel3" style="zoom:30%;" /> | 1. 提前创建好源交换器。<br/>2. 源端会自动创建匿名队列。<br/> |
| 交换器 |  队列  |                                                              | 1. 提前创建好源交换器，目标交换器和队列。<br/>2. 源端会自动创建匿名队列。<br/>3. 目的端会自动创建指定队列，使用默认交换器进行转发。 |
|  队列  | 交换器 | <img src="imgs/shovel1.png" alt="shovel1" style="zoom:25%;" /> | 1. 提前创建好源交换器，目标交换器和队列。<br/>2. 源端会自动创建指定队列。 |
|  队列  |  队列  | <img src="imgs/shovel2.png" alt="shovel2" style="zoom:32%;" /> | 1. 提前创建好源交换器。<br/>2. 源端会自动创建指定队列。<br/>3. 目的端会自动创建指定队列，使用默认交换器进行转发。 |

### 使用

在源broker或者目标broker部署shovel。

1. 部署方式：
   1. 静态方式：在rabbitmq.config中设置。

   2. 动态方式：通过 Runtime Parameter 设置。

      1. 通过rabbitmqctl命令。

         ```shell
         rabbitmqctl set parameter shovel shovelName '{"src-uri":"amqp://username:password@ip:port", "src-queue ":"srcQueueName", "dest-uri":"amqp://username:password@ip:port", "src-exchange-key":"rkName", "prefetch-count":number, "reconnect-delay":seconds, "publish-properties":[], "add-forward-headers":true, "ack-mode":"on-confirm"}'

      2. web管理端，在 "Admin" -> "Shovel Management" -> "Add a new shovel" 中创建。

2. 参数

   1. name：shovel名称
   2. source：
      1. url：定义source的AMQP的连接。
      2. queue：队列名称。
      3. prefetch-count：定义 Shovel 内部缓存的消息条数，即在收到上游消息之后，在发送到下游之前缓存的消息条数。
      4. auto_delete：队列是否持久化。
   3. destination
      1. url：定义destination的AMQP的连接。
      2. queue：队列名称。
      3. add-forwarding-headers：如果设置为 true ，则会在转发的消息内添加 x-shovelled的header 属性。
   4. reconnect-delay：Shovel link 由于某种原因断开之后，需要等待多少秒开始重新建立连接。
   5. ack-mode：Shovel link 的消息确认方式。
      1. on-confirm：**todo**
      2. on-publish
      3. no-ack：

### 应用场景

**消息堆积**：当节点node1中的队列queue1消息严重堆积时。

1. 启动node2节点，创建queue2，创建shovel1，把queue1中的消息转发给queue2。
2. 当queue1消息数*低于100万*或大小*低于1GB*时，停止shovel1，等待queue1中的消息处理。
3. 当queue1消息数*低于10万*或大小*低于1MB*时，启动shovel2，将queue2中的消息还给queue1。
4. 当queue1消息数*超过100万*或大小*高于1GB*时，停止shovel2。
5. 循环往复。

