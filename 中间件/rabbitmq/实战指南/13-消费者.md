# 消费者

## 概念

连接服务器，订阅到**队列**上。

### 消费消息过程

1. 消费者连接到RabbitMQ实例，建立一个连接、开启一个信道。
2. 请求消费队列中的消息，可能设置相应的回调函数，做一些准备工作。
3. 等待实例回应并投递消息，消费者接收。
4. 消费者确认【ack】消息接受。
5. RabbitMQ从队列中删除已被确认的消息。
6. 关闭信道。
7. 关闭连接。

### 消息分发机制

1. 分发机制：轮询分发【n%m】:n-第几条消费者，m:消费者个数。
2. 缺陷：消费者处理消息的能力有差异，对于性能较差的消费者会出现消费积压，恶性循环。
3. 解决办法：对消费者设置Qos【消费者可以持有的未确认的消息数量】。

## 基本操作

### 消费消息

#### 推模式【推荐】

##### 示例

```java
String basicConsume(
  String queue, 
  boolean autoAck, 
  String consumerTag, 
  boolean noLocal, 
  boolean exclusive, 
  Map<String, Object> arguments, 
  Consumer callback
) throws IOException;
```

##### 参数

1. queue：队列名称。

2. autoAck：设置是否自动确认，建议设置为false。

   1. true：发出去的消息自动确认，然后从内存（磁盘）中删除，不关心消费者是否消费成功。

   2. false:  

      1. 消费者显式的调用Basic.Ack时，才会把消息删除。
      2. 队列中的消息分为2个部分：
         1. ready：等待被消费的消息。
         2. unacknowledge：等待被确认的消息。
      3. 待被确认的消息不会有过期时间，当消费者与队列断开连接时【**唯一条件**】，消息重新入队。
   
3. consumerTag：消费者标签，用来区分多个消费者。

4. noLocal：消费者不消费同一连接中生产者发送的消息。

5. exclusive：设置是否排他。true表示只有1个消费者来消费消息。

6. arguments：参数

   1. x-cancel-on-ha-failover：镜像队列的master节点挂掉，消费者客户端通过handleCancel方法感知master宕机。

7. callback

   设置消费者的回调函数。

   1. handleDelivery：队列向消费者推消息时调用。**basic.deliver**

      ```java
      void handleDelivery(
        String consumerTag,
        Envelope envelope,
        AMQP.BasicProperties properties,
        byte[] body
      )throws IOException;
      ```

      1. envelope：环境变量。

   2. handleConsumeOk：开始消费时调用。**Channel.basicConsume**

      ```java
      void handleConsumeOk(String consumerTag);
      ```

   3. handleCancel：取消订阅时调用

      ```java
      void handleCancel(String consumerTag) throws IOException;
      ```

   4. handleCancelOk：取消订阅时调用

      ```java
      void handleCancelOk(String consumerTag);
      ```

   5. handleShutdownSignal：channel或connection关闭时调用

      ```java
      void handleShutdownSignal(String consumerTag, ShutdownSignalException sig);
      ```

   13. handleRecoverOk：重新发送未被确认的消息时调用。

       ```java
       void handleRecoverOk(String consumerTag);
       ```

#### 拉模式

```java
GetResponse basicGet(String queue, boolean autoAck) throws IOException;
```

1. queue：队列名称。
2. autoAck：是否自动确认。

### 确认消息

#### basicAck

```java
void basicAck(long deliveryTag, boolean multiple) throws IOException;
```

1. deliveryTag：消息编号

2. multiple

   1. **true**：只确认当前的消息。
   2. **false**：确认当前以及之前的所有未确认的消息。

### 拒绝消息

#### basicReject

```java
void basicReject(long deliveryTag, boolean requeue) throws IOException;
```

1. deliveryTag：消息编号。

2. requeue
   1. **true**：重新入队。
   2. **false**：直接移除。

#### basicNack

```java
void basicNack(
  long deliveryTag, 
  boolean multiple, 
  boolean requeue) throws IOException;
```

1. deliveryTag：消息编号。
2. multiple
   1. **false**：只拒绝当前消息。
   2. **true**：拒绝deliveryTag编号之前未被该消费者确认的消息。

#### basicRecover

```java
Basic.RecoverOk basicRecover(boolean requeue) throws IOException;
```

requeue：默认true。

1. **true**：重新加入列表，再分配时，可能被分配给与之前不同的消费者。
2. **false**：重新加入列表，再分配时，可能被分配给与之前相同的消费者。

### Qos设置

#### 定义

```java
channel.basicQos(int prefetchSize, int prefetchCount, boolean gobal);
```

#### 参数

1. prefetchSize：消费者可以持有的未确认的消息总大小。
2. prefetchCount：消费者可以持有的未确认的消息数量。
3. gobal：在一个信道中有多个消费者时消费多个队列时使用。
   1. false：新的消费者可以持有的未确认的消息数量。
   2. true：信道中所有消费者总共可以持有的未确认的消息数量。

## 管理

```shell
rabbitmqctl list_consumers [-p vhost]
```

1. 已订阅队列的名称。
2. 相关信道的进程标识。
3. consumerTag。
4. 是否需要消费端确认。
5. prefetch_ count。
6. 参数列表。