# 连接

1. `Connection`可以用来创建多个`Channel`实例。
2. `Channel`实例不能线程间共享，每个线程应该创建一个`Channel`实例。

# 交换器

建议预先创建资源，通过后台管理系统。

## 声明交换器

```java
Exchange.DeclareOk exchangeDeclare(
 	String exchange,
  BuiltinExchangeType type,
  boolean durable,
  boolean autoDelete,
  boolean internal,
  Map<String, Object> arguments
) throws IOException;
```

1. exchange：交换器名称。
2. type：交换器类型，fanout、direct、topic等。
3. durable：是否持久化。true为持久化，将交换器存盘。
4. autoDelete：自动删除。true为当所有绑定队列都不在使用时，自动删除交换器。【**一次性**】
   1. 前提：必须有交换机或队列绑定过。
   2. 所有绑定都断开时，自动删除。
5. internal：是否设置成内置的。true为必须通过交换器路由到此交换器。
6. arguments：结构化参数。
   1. 备份交换器：alternate-exchange

## 绑定交换器

```java
Exchange.BindOk exchangeBind(
  String destination, 
  String source, 
  String routingKey, 
  Map<String, Object> arguments
) throws IOException;
```

1. destination：目标交换器。
   1. 一般目标交换器类型为：fanout。
2. source：源交换器。

## 解绑交换器

```java
Exchange.UnbindOk exchangeUnbind(
  String destination, 
  String source, 
  String routingKey, 
  Map<String, Object> arguments
) throws IOException;
```

# 队列

建议预先创建资源，通过后台管理系统。

## 声明队列

```java
Queue.DeclareOk queueDeclare(
  String queue, 
  boolean durable, 
  boolean exclusive, 
  boolean autoDelete,
  Map<String, Object> arguments
) throws IOException;
```

1. queue：队列名称。
2. durable：是否持久化。true为持久化，将队列存盘。
3. exclusive：是否排他，true为排他，仅对首次声明他的队列连接可见。
   1. 基于连接。
   2. 同一连接的不同信道可同时访问同一连接创建的排他队列。
   3. 排他队列全局不可重名。
   4. <span style="color:red">连接关闭或客户端退出时删除</span>，**即使持久化**。
4. autoDelete：自动删除。所有与这个队列连接的消费者都断开时，删除队列。【**一次性**】
   1. 前提：必须有一个消费者连接过。
   2. 所有消费者都断开时，自动删除。
5. arguments：结构化参数。
   1. 死信交换器：x-dead-letter-exchange
   2. 死信路由键：x-dead-letter-routing-key
   3. 队列最大长度：x-max-length

## 声明已有队列

```java
Queue.DeclareOk queueDeclarePassive(String queue) throws IOException;
```

1. 队列不存在时抛出 404 异常。

## 删除队列

```java
Queue.DeleteOk queueDelete(String queue, boolean ifUnused, boolean ifEmpty) throws IOException;
```

### 不建议使用

```java
void queueDeleteNoWait(String queue, boolean ifUnused, boolean ifEmpty) throws IOException;
```

无返回值。

## 绑定队列

```java
Queue.BindOk queueBind(
  String queue, 
  String exchange, 
  String routingKey, 
  Map<String, Object> arguments
) throws IOException;
```

1. queue：队列名称。
2. exchange：交换器名称。
3. routingKey：绑定队列和交换器的路由键。
4. arguments：绑定时的额外参数。

## 解绑队列

```java
Queue.UnbindOk queueUnbind(
  String queue,
  String exchange, 
  String routingKey, 
  Map<String, Object> arguments
) throws IOException;
```

## 注意

1. 消费者在同一信道订阅其他队列后，不可再声明队列。【订阅排他】

# 发送消息

## 示例

```java
void basicPublish(
  String exchange, 
  String routingKey, 
  boolean mandatory, 
  boolean immediate, 
  BasicProperties props, 
  byte[] body
) throws IOException;
```

## 参数

### exchange

交换器名称。设置为空时，消息会被发送到默认的交换器中。

### routingKey

指定的路由键。

### mandatory

1. `true`：当交换器找不到符合条件的对列，rabbitMQ调用`Basic.Return` 将消息退回给生产者。获取方式如下：

   ```java
   channel.addReturnListener(
     new ReturnListener() {
       @Override
       public void handleReturn(
         int replyCode,
         String replyText,
         String exchange,
         String routingKey,
         AMQP.BasicProperties properties,
         byte[] body) throws IOException {
         System.out.println("Basic.return 返回的消息是:" + new String(body));
       }
   });
   ```

   1. 新增监听器。`channel.addReturnListener`。
   2. 监听器中实现 `handleReturn` 方法。

2. `false`：当交换器找不到符合条件的对列，直接丢弃消息。

### immediate

1. `true`：交换器将消息路由到队列时，发现队列上不存在消费者，将不会入队，如果所有队列都没消费者，rabbitMQ调用`Basic.Return` 将消息退回给生产者。
2. `false`：默认。
3. 3.0去掉了，影响镜像队列性能，增加了代码复杂性。

### props

消息的基本属性集。

#### content-type

让消费者知道如何解释消息体。

#### content-encoding

指示消息体使用某种特殊的方式进行压缩或编码。

#### message-id

唯一消息标识。可以用于去重。

#### correlation-id

消息响应标识。可以用于拓扑排序。

#### timestamp

表示消息创建时间。

#### expiration

表示消息的过期时间。

1. UNIX纪元时间或整数时间戳，然后把它存储为字符串。精度是毫秒。
2. 已经超时的消息发布到服务器，不会被路由到任何队列，而是被直接丢弃。

#### delivery-mode

将消息写入磁盘或内存队列。`1`：非持久化消息。`2`：持久化消息。

#### app-id和user-id

帮助追踪出现问题的消息发布者应用程序。

#### type

1. 表示发布者和消费者之间的契约。
2. 一般可以用于描述消息中的内容，应用程序可以根据它来确定如何处理一个消息。

#### reply-to

实现响应消息的路由。

#### headers

定义自由格式的属性和实现RabbitMQ路由。

1. key可以是ASCII或Unicode字符串，最大长度为255个字符。
2. value可以是任何有效的AMQP值类型。

#### priority

值被定义为0~9之间。用于指定队列中消息的优先级。**不建议使用**。

### body

消息体，真正要发送的消息。

# 消费消息

## 推模式【推荐】

### 示例

```java
String basicConsume(
  String queue, 
  boolean autoAck, 
  String consumerTag, 
  boolean noLocal, 
  boolean exclusive, 
  Map<String, Object> arguments, 
  Consumer callback
) throws IOException;
```

### 参数

#### queue

队列名称。

#### autoAck

设置是否自动确认，建议设置为false。

1. true：发出去的消息自动确认，然后从内存（磁盘）中删除，不关心消费者是否消费成功。

2. false:  

   1. 消费者显式的调用Basic.Ack时，才会把消息删除。
   2. 队列中的消息分为2个部分：
      1. ready：等待被消费的消息。
      2. unacknowledge：等待被确认的消息。
   3. 待被确认的消息不会有过期时间，当消费者与队列断开连接时【**唯一条件**】，消息重新入队。

#### consumerTag

消费者标签，用来区分多个消费者。

#### noLocal

消费者不消费同一连接中生产者发送的消息。

#### exclusive

设置是否排他。true表示只有1个消费者来消费消息。

#### arguments

#### callback

设置消费者的回调函数。

##### handleDelivery

1. 示例

   ```java
   void handleDelivery(
     String consumerTag,
     Envelope envelope,
     AMQP.BasicProperties properties,
     byte[] body
   )throws IOException;
   ```

2. 参数

   envelope：环境变量。

3. 调用时机

   队列向消费者推消息`basic.deliver`时调用。

##### handleConsumeOk

1. 示例

   ```java
   void handleConsumeOk(String consumerTag);
   ```

2. 调用时机

   开始消费`Channel.basicConsume`时调用。

##### handleCancel

1. 示例

   ```java
   void handleCancel(String consumerTag) throws IOException;
   ```

2. 调用时机

   取消订阅时调用。

##### handleCancelOk

1. 示例

   ```java
   void handleCancelOk(String consumerTag);
   ```

2. 调用时机

   取消订阅时调用。

##### handleShutdownSignal

1. 示例

   ```java
   void handleShutdownSignal(String consumerTag, ShutdownSignalException sig);
   ```

2. 调用时机

   channel或connection关闭时调用。

##### handleRecoverOk

1. 示例

   ```java
   void handleRecoverOk(String consumerTag);
   ```

2. 调用时机

   重新发送未被确认的消息时调用。

## 拉模式

```java
GetResponse basicGet(String queue, boolean autoAck) throws IOException;
```

1. queue：队列名称。
2. autoAck：是否自动确认。

## 确认与拒绝

### 确认【basicAck】

#### 示例

```java
void basicAck(long deliveryTag, boolean multiple) throws IOException;
```

#### 参数

##### deliveryTag

消息编号

##### multiple

1. true：只确认当前的消息。
2. false：确认当前以及之前的所有未确认的消息。

### 拒绝

#### basicReject

##### 示例

```java
void basicReject(long deliveryTag, boolean requeue) throws IOException;
```

##### 参数

###### deliveryTag

消息编号。

###### requeue

1. true：重新入队。
2. false：直接移除。

#### basicNack

##### 示例

```java
void basicNack(
  long deliveryTag, 
  boolean multiple, 
  boolean requeue) throws IOException;
```

##### 参数

###### multiple

1. false：只拒绝当前消息。
2. true：拒绝deliveryTag编号之前未被该消费者确认的消息。

#### basicRecover

##### 示例

```java
Basic.RecoverOk basicRecover(boolean requeue) throws IOException;
```

##### 参数

###### requeue

 默认true。

1. true：重新加入列表，再分配时，可能被分配给与之前不同的消费者。
2. false：重新加入列表，再分配时，可能被分配给与之前相同的消费者。

