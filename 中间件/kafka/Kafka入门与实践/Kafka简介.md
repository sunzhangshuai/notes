# 基本结构

消费者【Consumer】：负责从kafka集群拉取消息

生产者【Producer】：负责把消息写入kafka集群

# 基本概念

## 主题

1. 一组消息。
2. 生产者将消息发送到特定主题。
3. 消费者订阅主题或主题的一些分区。

## 消息

1. kafka通信的基本单位。

2. 组成：由固定长度的消息头和可变长度的消息体组成。
3. 在java中每一条消息称为Record。
4. 消息删除策略
   1. 基于消息已存储的时间长度。
   2. 基于分区的大小。

## 分区和副本

1. 一个主题可以有1-多个分区。

2. 1个分区可以有1-多个副本。

### 分区【Partition】

1. 分区由一系列消息组成，消息有序，不可变。
2. 分区在物理上对应一个文件夹，命名规则：主题名称+"-"+编号【0-分区总数-1】。
3. 指定分区数
   1. 启动时加载的配置文件中配置。
   2. 创建主题时指定。
   3. 创建主题后修改分区数。
4. 分区内消息有序，跨分区无序。

### 副本【Replica】

1. 分区的副本分布在集群的不同代理上。
2. 副本可以看做一个日志对象。

#### Leader副本

1. 负责处理客户端的读写请求。
2. leader失效，通过选举算法从follower选出一个新leader。

#### Follower副本

从leader副本同步数据。

## 偏移量

分区下严格有序的逻辑值，不代表消息在磁盘中的物理位置。

## 日志段

1. 一个日志由多个日志段组成。
2. 日志段是日志对象分片的最小单位。
3. 一个日志段对应磁盘上一个具体日志文件和两个索引文件。
   1. .log：保存消息实际数据
   2. .index：表示消息偏移量
   3. .timeIndex：消息时间戳索引文件

## 代理【Broker】

1. kafka集群的一个实例。

2. 一个服务器可以有多个代理。
3. 每个代理都有全局唯一标识id。
4. id是非负整数。

## 生产者【Producer】

向kafka代理发送消息的客户端。

## 消费者和消费组

1. 消费的客户端。
2. 每一个消费者都属于一个特定的消费组【ConsumerGroup】。
3. 不指定消费组的，属于默认消费组，名称是 `test-consumer-group`。
4. 消费者有全局唯一id，不指定则自动生成一个，格式为 `${groupId}-${hostName}-${timeStamp}-${UUID前8位字符}`。
5. 同一个主题的一条消息只能被一个消费组的一个消费者消费，但不同消费组的消费者可以同时消费该消息。

## ISR

1. 保存所有与leader副本保持消息同步的所有副本对应的代理节点id。

2. 代理失效，副本节点从ISR中移除。
3. 代理失效：人为关闭、物理故障、心跳检测过期、网络延迟、进程崩溃、同步落后太多。

## ZooKeeper

1. 保存元数据信息。
2. 元数据信息：代理节点信息、kafka集群信息、旧版消费者信息、消费偏移量信息、主题信息、分区状态信息、分区副本分配方案信息、动态配置信息。
3. 用来维护kafka集群，方便进行水平扩展和数据迁移。

# 特性

## 消息持久化

数据落盘

## 高吞吐量

顺序读写磁盘、副本同步时零拷贝技术、主题分区、消息压缩、批量发送。

支持每秒百万级别的消息。

## 扩展性

用zookeeper管理集群，更容易进行水平扩展

## 多客户端支持

客户端支持多种语言，大数据框架

## kafka streams

## 安全机制

1. 通过ssl支持生产者，消费者与代理连接的身份验证。
2. 代理与zookeeper连接的身份验证。
3. 通信时数据加密。
4. 客户端读写权限认证。
5. kafka支持与外部其他认证服务的集成。

## 数据备份

每个主题可以指定副本数。

## 轻量级

代理无状态。

## 消息压缩

Gzip、Snappy、LZ4

多条消息可以放在一起组成MessageSet，再把messageSet放到一条消息里。

# 应用场景

1. 消息系统
2. 应用监控
3. 网站用户行为追踪
4. 流处理
5. 持久性日志

















